<HTML><HEAD><META CONTENT="text/html; charset=UTF-8" HTTP-EQUIV="Content-Type"/><TITLE>EMMA Coverage Report</TITLE><STYLE TYPE="text/css"> TABLE,TD,TH {border-style:solid; border-color:black;} TD,TH {background:white;margin:0;line-height:100%;padding-left:0.5em;padding-right:0.5em;} TD {border-width:0 1px 0 0;} TH {border-width:1px 1px 1px 0;} TR TD.h {color:red;} TABLE {border-spacing:0; border-collapse:collapse;border-width:0 0 1px 1px;} P,H1,H2,H3,TH {font-family:verdana,arial,sans-serif;font-size:10pt;} TD {font-family:courier,monospace;font-size:10pt;} TABLE.hdft {border-spacing:0;border-collapse:collapse;border-style:none;} TABLE.hdft TH,TABLE.hdft TD {border-style:none;line-height:normal;} TABLE.hdft TH.tl,TABLE.hdft TD.tl {background:#6699CC;color:white;} TABLE.hdft TD.nv {background:#6633DD;color:white;} .nv A:link {color:white;} .nv A:visited {color:white;} .nv A:active {color:yellow;} TABLE.hdft A:link {color:white;} TABLE.hdft A:visited {color:white;} TABLE.hdft A:active {color:yellow;} .in {color:#356085;} TABLE.s TD {padding-left:0.25em;padding-right:0.25em;} TABLE.s TD.l {padding-left:0.25em;padding-right:0.25em;text-align:right;background:#F0F0F0;} TABLE.s TR.z TD {background:#FF9999;} TABLE.s TR.p TD {background:#FFFF88;} TABLE.s TR.c TD {background:#CCFFCC;} A:link {color:#0000EE;text-decoration:none;} A:visited {color:#0000EE;text-decoration:none;} A:hover {color:#0000EE;text-decoration:underline;} TABLE.cn {border-width:0 0 1px 0;} TABLE.s {border-width:1px 0 1px 1px;} TD.h {color:red;border-width:0 1px 0 0;} TD.f {border-width:0 1px 0 1px;} TD.hf {color:red;border-width:0 1px 0 1px;} TH.f {border-width:1px 1px 1px 1px;} TR.cis TD {background:#F0F0F0;} TR.cis TD {border-width:1px 1px 1px 0;} TR.cis TD.h {color:red;border-width:1px 1px 1px 0;} TR.cis TD.f {border-width:1px 1px 1px 1px;} TR.cis TD.hf {color:red;border-width:1px 1px 1px 1px;} TD.b {border-style:none;background:transparent;line-height:50%;}  TD.bt {border-width:1px 0 0 0;background:transparent;line-height:50%;} TR.o TD {background:#F0F0F0;}TABLE.it {border-style:none;}TABLE.it TD,TABLE.it TH {border-style:none;}</STYLE></HEAD><BODY><TABLE WIDTH="100%" CLASS="hdft" CELLSPACING="0"><TR><TH CLASS="tl"><A HREF="http://emma.sourceforge.net/">EMMA</A> Coverage Report (generated Thu Nov 16 15:09:53 CET 2017)</TH></TR><TR><TD CLASS="nv">[<A HREF="../index.html">all classes</A>][<A HREF="15.html">org.apache.catalina.tribes.tipis</A>]</TD></TR></TABLE><H2>COVERAGE SUMMARY FOR SOURCE FILE [<SPAN CLASS="in">AbstractReplicatedMap.java</SPAN>]</H2><TABLE WIDTH="100%" CELLSPACING="0"><TR><TH>name</TH><TH>class, %</TH><TH>method, %</TH><TH>block, %</TH><TH>line, %</TH></TR><TR><TD>AbstractReplicatedMap.java</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/110)</TD><TD CLASS="h">0%   (0/3422)</TD><TD CLASS="h">0%   (0/729)</TD></TR></TABLE><H3>COVERAGE BREAKDOWN BY CLASS AND METHOD</H3><TABLE WIDTH="100%" CLASS="cn" CELLSPACING="0"><TR><TH CLASS="f">name</TH><TH>class, %</TH><TH>method, %</TH><TH>block, %</TH><TH>line, %</TH></TR><TR><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD></TR><TR CLASS="cis"><TD CLASS="f">class <A HREF="#0">AbstractReplicatedMap</A></TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/63)</TD><TD CLASS="h">0%   (0/2827)</TD><TD CLASS="h">0%   (0/581)</TD></TR><TR><TD CLASS="f"><A HREF="#0">AbstractReplicatedMap (AbstractReplicatedMap$MapOwner, Channel, long, String,...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/52)</TD><TD CLASS="h">0%   (0/13)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#2">accept (Serializable, Member): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/58)</TD><TD CLASS="h">0%   (0/6)</TD></TR><TR><TD CLASS="f"><A HREF="#3">breakdown (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#4">broadcast (int, boolean): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/81)</TD><TD CLASS="h">0%   (0/14)</TD></TR><TR><TD CLASS="f"><A HREF="#5">clear (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#6">clear (boolean): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/20)</TD><TD CLASS="h">0%   (0/7)</TD></TR><TR><TD CLASS="f"><A HREF="#7">clone (): Object</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/5)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#8">containsKey (Object): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/5)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#9">containsValue (Object): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/40)</TD><TD CLASS="h">0%   (0/9)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#a">entrySet (): Set</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/41)</TD><TD CLASS="h">0%   (0/10)</TD></TR><TR><TD CLASS="f"><A HREF="#b">entrySetFull (): Set</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#c">equals (Object): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/22)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR><TD CLASS="f"><A HREF="#d">excludeFromSet (Member [], Member []): Member []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/49)</TD><TD CLASS="h">0%   (0/7)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#e">finalize (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/42)</TD><TD CLASS="h">0%   (0/13)</TD></TR><TR><TD CLASS="f"><A HREF="#f">get (Object): Object</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/233)</TD><TD CLASS="h">0%   (0/40)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#10">getAccessTimeout (): long</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#11">getChannel (): Channel</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#12">getChannelSendOptions (): int</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#13">getExternalLoaders (): ClassLoader []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#14">getInternal (Object): AbstractReplicatedMap$MapEntry</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/6)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#15">getMapContextName (): byte []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#16">getMapMembers (): Member []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/5)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#17">getMapMembers (HashMap): Member []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/22)</TD><TD CLASS="h">0%   (0/5)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#18">getMapMembersExcl (Member []): Member []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/35)</TD><TD CLASS="h">0%   (0/5)</TD></TR><TR><TD CLASS="f"><A HREF="#19">getMapOwner (): AbstractReplicatedMap$MapOwner</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#1a">getNextBackupIndex (): int</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/28)</TD><TD CLASS="h">0%   (0/7)</TD></TR><TR><TD CLASS="f"><A HREF="#1b">getNextBackupNode (): Member</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/24)</TD><TD CLASS="h">0%   (0/5)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#1c">getRpcChannel (): RpcChannel</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#1d">getRpcTimeout (): long</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#1e">getStateMutex (): Object</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#1f">hashCode (): int</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#20">heartbeat (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/12)</TD><TD CLASS="h">0%   (0/5)</TD></TR><TR><TD CLASS="f"><A HREF="#21">inSet (Member, Member []): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/26)</TD><TD CLASS="h">0%   (0/5)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#22">init (AbstractReplicatedMap$MapOwner, Channel, String, long, int, ClassLoader...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/132)</TD><TD CLASS="h">0%   (0/28)</TD></TR><TR><TD CLASS="f"><A HREF="#23">isEmpty (): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/7)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#24">isStateTransferred (): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#25">keySet (): Set</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/41)</TD><TD CLASS="h">0%   (0/9)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#26">keySetFull (): Set</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#27">leftOver (Serializable, Member): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/43)</TD><TD CLASS="h">0%   (0/13)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#28">mapMemberAdded (Member): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/111)</TD><TD CLASS="h">0%   (0/24)</TD></TR><TR><TD CLASS="f"><A HREF="#29">memberAdded (Member): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#2a">memberAlive (Member): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/31)</TD><TD CLASS="h">0%   (0/6)</TD></TR><TR><TD CLASS="f"><A HREF="#2b">memberDisappeared (Member): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/290)</TD><TD CLASS="h">0%   (0/52)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#2c">messageReceived (Serializable, Member): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/335)</TD><TD CLASS="h">0%   (0/70)</TD></TR><TR><TD CLASS="f"><A HREF="#2d">ping (long): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/135)</TD><TD CLASS="h">0%   (0/21)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#2e">printMap (String): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/103)</TD><TD CLASS="h">0%   (0/19)</TD></TR><TR><TD CLASS="f"><A HREF="#2f">put (Object, Object): Object</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/6)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#30">put (Object, Object, boolean): Object</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/53)</TD><TD CLASS="h">0%   (0/14)</TD></TR><TR><TD CLASS="f"><A HREF="#31">putAll (Map): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/20)</TD><TD CLASS="h">0%   (0/6)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#32">remove (Object): Object</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/5)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#33">remove (Object, boolean): Object</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/49)</TD><TD CLASS="h">0%   (0/8)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#34">replicate (Object, boolean): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/205)</TD><TD CLASS="h">0%   (0/43)</TD></TR><TR><TD CLASS="f"><A HREF="#35">replicate (boolean): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/19)</TD><TD CLASS="h">0%   (0/6)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#36">replyRequest (Serializable, Member): Serializable</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/155)</TD><TD CLASS="h">0%   (0/31)</TD></TR><TR><TD CLASS="f"><A HREF="#37">setAccessTimeout (long): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#38">setChannelSendOptions (int): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR><TD CLASS="f"><A HREF="#39">setExternalLoaders (ClassLoader []): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#3a">setMapOwner (AbstractReplicatedMap$MapOwner): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR><TD CLASS="f"><A HREF="#3b">size (): int</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/37)</TD><TD CLASS="h">0%   (0/9)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#3c">sizeFull (): int</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#3d">transferState (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/122)</TD><TD CLASS="h">0%   (0/23)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#3e">values (): Collection</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/40)</TD><TD CLASS="h">0%   (0/8)</TD></TR><TR><TD CLASS="f"><A HREF="#3f">wrap (Member): Member []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/12)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD></TR><TR CLASS="cis"><TD CLASS="f">class <A HREF="#40">AbstractReplicatedMap$MapEntry</A></TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/23)</TD><TD CLASS="h">0%   (0/226)</TD><TD CLASS="h">0%   (0/52)</TD></TR><TR><TD CLASS="f"><A HREF="#40">AbstractReplicatedMap$MapEntry (Object, Object): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/11)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#42">apply (byte [], int, int, boolean): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/43)</TD><TD CLASS="h">0%   (0/12)</TD></TR><TR><TD CLASS="f"><A HREF="#43">equals (Object): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/5)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#44">getBackupNodes (): Member []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#45">getKey (): Object</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#46">getPrimary (): Member</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#47">getValue (): Object</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#48">hashCode (): int</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#49">isActive (): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/7)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#4a">isBackup (): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#4b">isDiffable (): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/13)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#4c">isKeySerializable (): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/11)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#4d">isPrimary (): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/10)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#4e">isProxy (): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#4f">isSerializable (): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/10)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#50">isValueSerializable (): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/11)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#51">setBackup (boolean): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#52">setBackupNodes (Member []): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR><TD CLASS="f"><A HREF="#53">setKey (Object): Object</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/8)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#54">setPrimary (Member): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR><TD CLASS="f"><A HREF="#55">setProxy (boolean): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#56">setValue (Object): Object</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/8)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR><TD CLASS="f"><A HREF="#57">toString (): String</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/51)</TD><TD CLASS="h">0%   (0/7)</TD></TR><TR><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD></TR><TR CLASS="cis"><TD CLASS="f">class <A HREF="#58">AbstractReplicatedMap$MapMessage</A></TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/24)</TD><TD CLASS="h">0%   (0/369)</TD><TD CLASS="h">0%   (0/96)</TD></TR><TR><TD CLASS="f"><A HREF="#59">AbstractReplicatedMap$MapMessage (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#5a">AbstractReplicatedMap$MapMessage (byte [], int, boolean, Serializable, Serial...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/33)</TD><TD CLASS="h">0%   (0/12)</TD></TR><TR><TD CLASS="f"><A HREF="#58">access$000 (AbstractReplicatedMap$MapMessage, Member): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#5c">clone (): Object</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/30)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR><TD CLASS="f"><A HREF="#5d">deserialize (ClassLoader []): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/9)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#5e">getBackupNodes (): Member []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#5f">getDiffValue (): byte []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#60">getKey (): Serializable</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/11)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR><TD CLASS="f"><A HREF="#61">getKeyData (): byte []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#62">getMapId (): byte []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#63">getMsgType (): int</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#64">getPrimary (): Member</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#65">getTypeDesc (): String</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/27)</TD><TD CLASS="h">0%   (0/13)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#66">getValue (): Serializable</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/11)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR><TD CLASS="f"><A HREF="#67">getValueData (): byte []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#68">isDiff (): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#69">key (ClassLoader []): Serializable</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/31)</TD><TD CLASS="h">0%   (0/5)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#6a">readMembers (ObjectInput): Member []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/31)</TD><TD CLASS="h">0%   (0/7)</TD></TR><TR><TD CLASS="f"><A HREF="#6b">setKey (Serializable): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/17)</TD><TD CLASS="h">0%   (0/6)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#6c">setPrimary (Member): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR><TD CLASS="f"><A HREF="#6d">setValue (Serializable): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/17)</TD><TD CLASS="h">0%   (0/6)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#6e">toString (): String</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/43)</TD><TD CLASS="h">0%   (0/9)</TD></TR><TR><TD CLASS="f"><A HREF="#6f">value (ClassLoader []): Serializable</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/31)</TD><TD CLASS="h">0%   (0/5)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#70">writeMembers (ObjectOutput, Member []): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/43)</TD><TD CLASS="h">0%   (0/8)</TD></TR></TABLE><P></P><TABLE WIDTH="100%" CLASS="s" CELLSPACING="0"><TR><TD CLASS="l">1</TD><TD>/*</TD></TR><TR><TD CLASS="l">2</TD><TD> * Licensed to the Apache Software Foundation (ASF) under one or more</TD></TR><TR><TD CLASS="l">3</TD><TD> * contributor license agreements.  See the NOTICE file distributed with</TD></TR><TR><TD CLASS="l">4</TD><TD> * this work for additional information regarding copyright ownership.</TD></TR><TR><TD CLASS="l">5</TD><TD> * The ASF licenses this file to You under the Apache License, Version 2.0</TD></TR><TR><TD CLASS="l">6</TD><TD> * (the &#34;License&#34;); you may not use this file except in compliance with</TD></TR><TR><TD CLASS="l">7</TD><TD> * the License.  You may obtain a copy of the License at</TD></TR><TR><TD CLASS="l">8</TD><TD> *</TD></TR><TR><TD CLASS="l">9</TD><TD> *      http://www.apache.org/licenses/LICENSE-2.0</TD></TR><TR><TD CLASS="l">10</TD><TD> *</TD></TR><TR><TD CLASS="l">11</TD><TD> * Unless required by applicable law or agreed to in writing, software</TD></TR><TR><TD CLASS="l">12</TD><TD> * distributed under the License is distributed on an &#34;AS IS&#34; BASIS,</TD></TR><TR><TD CLASS="l">13</TD><TD> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</TD></TR><TR><TD CLASS="l">14</TD><TD> * See the License for the specific language governing permissions and</TD></TR><TR><TD CLASS="l">15</TD><TD> * limitations under the License.</TD></TR><TR><TD CLASS="l">16</TD><TD> */</TD></TR><TR><TD CLASS="l">17</TD><TD>package org.apache.catalina.tribes.tipis;</TD></TR><TR><TD CLASS="l">18</TD><TD> </TD></TR><TR><TD CLASS="l">19</TD><TD>import java.io.IOException;</TD></TR><TR><TD CLASS="l">20</TD><TD>import java.io.ObjectInput;</TD></TR><TR><TD CLASS="l">21</TD><TD>import java.io.ObjectOutput;</TD></TR><TR><TD CLASS="l">22</TD><TD>import java.io.Serializable;</TD></TR><TR><TD CLASS="l">23</TD><TD>import java.io.UnsupportedEncodingException;</TD></TR><TR><TD CLASS="l">24</TD><TD>import java.util.ArrayList;</TD></TR><TR><TD CLASS="l">25</TD><TD>import java.util.Collection;</TD></TR><TR><TD CLASS="l">26</TD><TD>import java.util.Collections;</TD></TR><TR><TD CLASS="l">27</TD><TD>import java.util.HashMap;</TD></TR><TR><TD CLASS="l">28</TD><TD>import java.util.Iterator;</TD></TR><TR><TD CLASS="l">29</TD><TD>import java.util.LinkedHashSet;</TD></TR><TR><TD CLASS="l">30</TD><TD>import java.util.Map;</TD></TR><TR><TD CLASS="l">31</TD><TD>import java.util.Set;</TD></TR><TR><TD CLASS="l">32</TD><TD>import java.util.concurrent.ConcurrentHashMap;</TD></TR><TR><TD CLASS="l">33</TD><TD>import java.util.concurrent.ConcurrentMap;</TD></TR><TR><TD CLASS="l">34</TD><TD> </TD></TR><TR><TD CLASS="l">35</TD><TD>import org.apache.catalina.tribes.Channel;</TD></TR><TR><TD CLASS="l">36</TD><TD>import org.apache.catalina.tribes.ChannelException;</TD></TR><TR><TD CLASS="l">37</TD><TD>import org.apache.catalina.tribes.ChannelException.FaultyMember;</TD></TR><TR><TD CLASS="l">38</TD><TD>import org.apache.catalina.tribes.ChannelListener;</TD></TR><TR><TD CLASS="l">39</TD><TD>import org.apache.catalina.tribes.Heartbeat;</TD></TR><TR><TD CLASS="l">40</TD><TD>import org.apache.catalina.tribes.Member;</TD></TR><TR><TD CLASS="l">41</TD><TD>import org.apache.catalina.tribes.MembershipListener;</TD></TR><TR><TD CLASS="l">42</TD><TD>import org.apache.catalina.tribes.group.Response;</TD></TR><TR><TD CLASS="l">43</TD><TD>import org.apache.catalina.tribes.group.RpcCallback;</TD></TR><TR><TD CLASS="l">44</TD><TD>import org.apache.catalina.tribes.group.RpcChannel;</TD></TR><TR><TD CLASS="l">45</TD><TD>import org.apache.catalina.tribes.io.XByteBuffer;</TD></TR><TR><TD CLASS="l">46</TD><TD>import org.apache.catalina.tribes.membership.MemberImpl;</TD></TR><TR><TD CLASS="l">47</TD><TD>import org.apache.catalina.tribes.util.Arrays;</TD></TR><TR><TD CLASS="l">48</TD><TD>import org.apache.juli.logging.Log;</TD></TR><TR><TD CLASS="l">49</TD><TD>import org.apache.juli.logging.LogFactory;</TD></TR><TR><TD CLASS="l">50</TD><TD> </TD></TR><TR><TD CLASS="l">51</TD><TD>/**</TD></TR><TR><TD CLASS="l">52</TD><TD> *</TD></TR><TR><TD CLASS="l">53</TD><TD> * @version 1.0</TD></TR><TR><TD CLASS="l">54</TD><TD> */</TD></TR><TR><TD CLASS="l">55</TD><TD>public abstract class AbstractReplicatedMap&lt;K,V&gt;</TD></TR><TR><TD CLASS="l">56</TD><TD>        implements Map&lt;K,V&gt;, Serializable, RpcCallback, ChannelListener,</TD></TR><TR><TD CLASS="l">57</TD><TD>        MembershipListener, Heartbeat {</TD></TR><TR><TD CLASS="l">58</TD><TD> </TD></TR><TR><TD CLASS="l">59</TD><TD>    private static final long serialVersionUID = 1L;</TD></TR><TR><TD CLASS="l">60</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">61</TD><TD>    private final Log log = LogFactory.getLog(AbstractReplicatedMap.class);</TD></TR><TR><TD CLASS="l">62</TD><TD> </TD></TR><TR><TD CLASS="l">63</TD><TD>    /**</TD></TR><TR><TD CLASS="l">64</TD><TD>     * The default initial capacity - MUST be a power of two.</TD></TR><TR><TD CLASS="l">65</TD><TD>     */</TD></TR><TR><TD CLASS="l">66</TD><TD>    public static final int DEFAULT_INITIAL_CAPACITY = 16;</TD></TR><TR><TD CLASS="l">67</TD><TD> </TD></TR><TR><TD CLASS="l">68</TD><TD>    /**</TD></TR><TR><TD CLASS="l">69</TD><TD>     * The load factor used when none specified in constructor.</TD></TR><TR><TD CLASS="l">70</TD><TD>     **/</TD></TR><TR><TD CLASS="l">71</TD><TD>    public static final float DEFAULT_LOAD_FACTOR = 0.75f;</TD></TR><TR><TD CLASS="l">72</TD><TD> </TD></TR><TR><TD CLASS="l">73</TD><TD>//------------------------------------------------------------------------------</TD></TR><TR><TD CLASS="l">74</TD><TD>//              INSTANCE VARIABLES</TD></TR><TR><TD CLASS="l">75</TD><TD>//------------------------------------------------------------------------------</TD></TR><TR><TD CLASS="l">76</TD><TD>    private final ConcurrentMap&lt;K, MapEntry&lt;K,V&gt;&gt; innerMap;</TD></TR><TR><TD CLASS="l">77</TD><TD> </TD></TR><TR><TD CLASS="l">78</TD><TD>    protected abstract int getStateMessageType();</TD></TR><TR><TD CLASS="l">79</TD><TD> </TD></TR><TR><TD CLASS="l">80</TD><TD> </TD></TR><TR><TD CLASS="l">81</TD><TD>    /**</TD></TR><TR><TD CLASS="l">82</TD><TD>     * Timeout for RPC messages, how long we will wait for a reply</TD></TR><TR><TD CLASS="l">83</TD><TD>     */</TD></TR><TR CLASS="z"><TD CLASS="l">84</TD><TD>    protected transient long rpcTimeout = 5000;</TD></TR><TR><TD CLASS="l">85</TD><TD>    /**</TD></TR><TR><TD CLASS="l">86</TD><TD>     * Reference to the channel for sending messages</TD></TR><TR><TD CLASS="l">87</TD><TD>     */</TD></TR><TR><TD CLASS="l">88</TD><TD>    protected transient Channel channel;</TD></TR><TR><TD CLASS="l">89</TD><TD>    /**</TD></TR><TR><TD CLASS="l">90</TD><TD>     * The RpcChannel to send RPC messages through</TD></TR><TR><TD CLASS="l">91</TD><TD>     */</TD></TR><TR><TD CLASS="l">92</TD><TD>    protected transient RpcChannel rpcChannel;</TD></TR><TR><TD CLASS="l">93</TD><TD>    /**</TD></TR><TR><TD CLASS="l">94</TD><TD>     * The Map context name makes this map unique, this</TD></TR><TR><TD CLASS="l">95</TD><TD>     * allows us to have more than one map shared</TD></TR><TR><TD CLASS="l">96</TD><TD>     * through one channel</TD></TR><TR><TD CLASS="l">97</TD><TD>     */</TD></TR><TR><TD CLASS="l">98</TD><TD>    protected transient byte[] mapContextName;</TD></TR><TR><TD CLASS="l">99</TD><TD>    /**</TD></TR><TR><TD CLASS="l">100</TD><TD>     * Has the state been transferred</TD></TR><TR><TD CLASS="l">101</TD><TD>     */</TD></TR><TR CLASS="z"><TD CLASS="l">102</TD><TD>    protected transient boolean stateTransferred = false;</TD></TR><TR><TD CLASS="l">103</TD><TD>    /**</TD></TR><TR><TD CLASS="l">104</TD><TD>     * Simple lock object for transfers</TD></TR><TR><TD CLASS="l">105</TD><TD>     */</TD></TR><TR CLASS="z"><TD CLASS="l">106</TD><TD>    protected final transient Object stateMutex = new Object();</TD></TR><TR><TD CLASS="l">107</TD><TD>    /**</TD></TR><TR><TD CLASS="l">108</TD><TD>     * A list of members in our map</TD></TR><TR><TD CLASS="l">109</TD><TD>     */</TD></TR><TR CLASS="z"><TD CLASS="l">110</TD><TD>    protected final transient HashMap&lt;Member, Long&gt; mapMembers = new HashMap&lt;Member, Long&gt;();</TD></TR><TR><TD CLASS="l">111</TD><TD>    /**</TD></TR><TR><TD CLASS="l">112</TD><TD>     * Our default send options</TD></TR><TR><TD CLASS="l">113</TD><TD>     */</TD></TR><TR CLASS="z"><TD CLASS="l">114</TD><TD>    protected transient int channelSendOptions = Channel.SEND_OPTIONS_DEFAULT;</TD></TR><TR><TD CLASS="l">115</TD><TD>    /**</TD></TR><TR><TD CLASS="l">116</TD><TD>     * The owner of this map, ala a SessionManager for example</TD></TR><TR><TD CLASS="l">117</TD><TD>     */</TD></TR><TR><TD CLASS="l">118</TD><TD>    protected transient MapOwner mapOwner;</TD></TR><TR><TD CLASS="l">119</TD><TD>    /**</TD></TR><TR><TD CLASS="l">120</TD><TD>     * External class loaders if serialization and deserialization is to be performed successfully.</TD></TR><TR><TD CLASS="l">121</TD><TD>     */</TD></TR><TR><TD CLASS="l">122</TD><TD>    protected transient ClassLoader[] externalLoaders;</TD></TR><TR><TD CLASS="l">123</TD><TD> </TD></TR><TR><TD CLASS="l">124</TD><TD>    /**</TD></TR><TR><TD CLASS="l">125</TD><TD>     * The node we are currently backing up data to, this index will rotate</TD></TR><TR><TD CLASS="l">126</TD><TD>     * on a round robin basis</TD></TR><TR><TD CLASS="l">127</TD><TD>     */</TD></TR><TR CLASS="z"><TD CLASS="l">128</TD><TD>    protected transient int currentNode = 0;</TD></TR><TR><TD CLASS="l">129</TD><TD> </TD></TR><TR><TD CLASS="l">130</TD><TD>    /**</TD></TR><TR><TD CLASS="l">131</TD><TD>     * Since the map keeps internal membership</TD></TR><TR><TD CLASS="l">132</TD><TD>     * this is the timeout for a ping message to be responded to</TD></TR><TR><TD CLASS="l">133</TD><TD>     * If a remote map doesn't respond within this timeframe,</TD></TR><TR><TD CLASS="l">134</TD><TD>     * its considered dead.</TD></TR><TR><TD CLASS="l">135</TD><TD>     */</TD></TR><TR CLASS="z"><TD CLASS="l">136</TD><TD>    protected transient long accessTimeout = 5000;</TD></TR><TR><TD CLASS="l">137</TD><TD> </TD></TR><TR><TD CLASS="l">138</TD><TD>    /**</TD></TR><TR><TD CLASS="l">139</TD><TD>     * Readable string of the mapContextName value</TD></TR><TR><TD CLASS="l">140</TD><TD>     */</TD></TR><TR CLASS="z"><TD CLASS="l">141</TD><TD>    protected transient String mapname = &#34;&#34;;</TD></TR><TR><TD CLASS="l">142</TD><TD> </TD></TR><TR><TD CLASS="l">143</TD><TD>//------------------------------------------------------------------------------</TD></TR><TR><TD CLASS="l">144</TD><TD>//              map owner interface</TD></TR><TR><TD CLASS="l">145</TD><TD>//------------------------------------------------------------------------------</TD></TR><TR><TD CLASS="l">146</TD><TD> </TD></TR><TR><TD CLASS="l">147</TD><TD>    public static interface MapOwner {</TD></TR><TR><TD CLASS="l">148</TD><TD>        // a typo, should have been &#34;objectMadePrimary&#34;</TD></TR><TR><TD CLASS="l">149</TD><TD>        public void objectMadePrimay(Object key, Object value);</TD></TR><TR><TD CLASS="l">150</TD><TD>    }</TD></TR><TR><TD CLASS="l">151</TD><TD> </TD></TR><TR><TD CLASS="l">152</TD><TD>//------------------------------------------------------------------------------</TD></TR><TR><TD CLASS="l">153</TD><TD>//              CONSTRUCTORS</TD></TR><TR><TD CLASS="l">154</TD><TD>//------------------------------------------------------------------------------</TD></TR><TR><TD CLASS="l">155</TD><TD> </TD></TR><TR><TD CLASS="l">156</TD><TD>    /**</TD></TR><TR><TD CLASS="l">157</TD><TD>     * Creates a new map</TD></TR><TR><TD CLASS="l">158</TD><TD>     * @param channel The channel to use for communication</TD></TR><TR><TD CLASS="l">159</TD><TD>     * @param timeout long - timeout for RPC messags</TD></TR><TR><TD CLASS="l">160</TD><TD>     * @param mapContextName String - unique name for this map, to allow multiple maps per channel</TD></TR><TR><TD CLASS="l">161</TD><TD>     * @param initialCapacity int - the size of this map, see HashMap</TD></TR><TR><TD CLASS="l">162</TD><TD>     * @param loadFactor float - load factor, see HashMap</TD></TR><TR><TD CLASS="l">163</TD><TD>     * @param cls - a list of classloaders to be used for deserialization of objects.</TD></TR><TR><TD CLASS="l">164</TD><TD>     * @param terminate - Flag for whether to terminate this map that failed to start.</TD></TR><TR><TD CLASS="l">165</TD><TD>     */</TD></TR><TR><TD CLASS="l">166</TD><TD>    public AbstractReplicatedMap(MapOwner owner,</TD></TR><TR><TD CLASS="l">167</TD><TD>                                 Channel channel,</TD></TR><TR><TD CLASS="l">168</TD><TD>                                 long timeout,</TD></TR><TR><TD CLASS="l">169</TD><TD>                                 String mapContextName,</TD></TR><TR><TD CLASS="l"><A NAME="0">170</A></TD><TD>                                 int initialCapacity,</TD></TR><TR><TD CLASS="l">171</TD><TD>                                 float loadFactor,</TD></TR><TR><TD CLASS="l">172</TD><TD>                                 int channelSendOptions,</TD></TR><TR><TD CLASS="l">173</TD><TD>                                 ClassLoader[] cls,</TD></TR><TR CLASS="z"><TD CLASS="l">174</TD><TD>                                 boolean terminate) {</TD></TR><TR CLASS="z"><TD CLASS="l">175</TD><TD>        innerMap = new ConcurrentHashMap&lt;K,MapEntry&lt;K, V&gt;&gt;(initialCapacity, loadFactor, 15);</TD></TR><TR CLASS="z"><TD CLASS="l">176</TD><TD>        init(owner, channel, mapContextName, timeout, channelSendOptions, cls, terminate);</TD></TR><TR><TD CLASS="l">177</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">178</TD><TD>    }</TD></TR><TR><TD CLASS="l">179</TD><TD> </TD></TR><TR><TD CLASS="l">180</TD><TD>    /**</TD></TR><TR><TD CLASS="l">181</TD><TD>     * Helper methods, wraps a single member in an array</TD></TR><TR><TD CLASS="l"><A NAME="3f">182</A></TD><TD>     * @param m Member</TD></TR><TR><TD CLASS="l">183</TD><TD>     * @return Member[]</TD></TR><TR><TD CLASS="l">184</TD><TD>     */</TD></TR><TR><TD CLASS="l">185</TD><TD>    protected Member[] wrap(Member m) {</TD></TR><TR CLASS="z"><TD CLASS="l">186</TD><TD>        if ( m == null ) return new Member[0];</TD></TR><TR CLASS="z"><TD CLASS="l">187</TD><TD>        else return new Member[] {m};</TD></TR><TR><TD CLASS="l">188</TD><TD>    }</TD></TR><TR><TD CLASS="l">189</TD><TD> </TD></TR><TR><TD CLASS="l">190</TD><TD>    /**</TD></TR><TR><TD CLASS="l">191</TD><TD>     * Initializes the map by creating the RPC channel, registering itself as a channel listener</TD></TR><TR><TD CLASS="l">192</TD><TD>     * This method is also responsible for initiating the state transfer</TD></TR><TR><TD CLASS="l">193</TD><TD>     * @param owner Object</TD></TR><TR><TD CLASS="l">194</TD><TD>     * @param channel Channel</TD></TR><TR><TD CLASS="l">195</TD><TD>     * @param mapContextName String</TD></TR><TR><TD CLASS="l">196</TD><TD>     * @param timeout long</TD></TR><TR><TD CLASS="l">197</TD><TD>     * @param channelSendOptions int</TD></TR><TR><TD CLASS="l">198</TD><TD>     * @param cls ClassLoader[]</TD></TR><TR><TD CLASS="l"><A NAME="22">199</A></TD><TD>     * @param terminate - Flag for whether to terminate this map that failed to start.</TD></TR><TR><TD CLASS="l">200</TD><TD>     */</TD></TR><TR><TD CLASS="l">201</TD><TD>    protected void init(MapOwner owner, Channel channel, String mapContextName,</TD></TR><TR><TD CLASS="l">202</TD><TD>            long timeout, int channelSendOptions,ClassLoader[] cls, boolean terminate) {</TD></TR><TR CLASS="z"><TD CLASS="l">203</TD><TD>        long start = System.currentTimeMillis();</TD></TR><TR CLASS="z"><TD CLASS="l">204</TD><TD>        if (log.isInfoEnabled()) log.info(&#34;Initializing AbstractReplicatedMap with context name:&#34;+mapContextName);</TD></TR><TR CLASS="z"><TD CLASS="l">205</TD><TD>        this.mapOwner = owner;</TD></TR><TR CLASS="z"><TD CLASS="l">206</TD><TD>        this.externalLoaders = cls;</TD></TR><TR CLASS="z"><TD CLASS="l">207</TD><TD>        this.channelSendOptions = channelSendOptions;</TD></TR><TR CLASS="z"><TD CLASS="l">208</TD><TD>        this.channel = channel;</TD></TR><TR CLASS="z"><TD CLASS="l">209</TD><TD>        this.rpcTimeout = timeout;</TD></TR><TR><TD CLASS="l">210</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">211</TD><TD>        this.mapname = mapContextName;</TD></TR><TR><TD CLASS="l">212</TD><TD>        //unique context is more efficient if it is stored as bytes</TD></TR><TR><TD CLASS="l">213</TD><TD>        try {</TD></TR><TR CLASS="z"><TD CLASS="l">214</TD><TD>            this.mapContextName = mapContextName.getBytes(&#34;ISO-8859-1&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">215</TD><TD>        } catch (UnsupportedEncodingException e) {</TD></TR><TR><TD CLASS="l">216</TD><TD>            // Impossible. All JVMs are required to support ISO-8859-1</TD></TR><TR CLASS="z"><TD CLASS="l">217</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">218</TD><TD>        if ( log.isTraceEnabled() ) log.trace(&#34;Created Lazy Map with name:&#34;+mapContextName+&#34;, bytes:&#34;+Arrays.toString(this.mapContextName));</TD></TR><TR><TD CLASS="l">219</TD><TD> </TD></TR><TR><TD CLASS="l">220</TD><TD>        //create an rpc channel and add the map as a listener</TD></TR><TR CLASS="z"><TD CLASS="l">221</TD><TD>        this.rpcChannel = new RpcChannel(this.mapContextName, channel, this);</TD></TR><TR><TD CLASS="l">222</TD><TD>        //add this map as a message listener</TD></TR><TR CLASS="z"><TD CLASS="l">223</TD><TD>        this.channel.addChannelListener(this);</TD></TR><TR><TD CLASS="l">224</TD><TD>        //listen for membership notifications</TD></TR><TR CLASS="z"><TD CLASS="l">225</TD><TD>        this.channel.addMembershipListener(this);</TD></TR><TR><TD CLASS="l">226</TD><TD> </TD></TR><TR><TD CLASS="l">227</TD><TD> </TD></TR><TR><TD CLASS="l">228</TD><TD>        try {</TD></TR><TR><TD CLASS="l">229</TD><TD>            //broadcast our map, this just notifies other members of our existence</TD></TR><TR CLASS="z"><TD CLASS="l">230</TD><TD>            broadcast(MapMessage.MSG_INIT, true);</TD></TR><TR><TD CLASS="l">231</TD><TD>            //transfer state from another map</TD></TR><TR CLASS="z"><TD CLASS="l">232</TD><TD>            transferState();</TD></TR><TR><TD CLASS="l">233</TD><TD>            //state is transferred, we are ready for messaging</TD></TR><TR CLASS="z"><TD CLASS="l">234</TD><TD>            broadcast(MapMessage.MSG_START, true);</TD></TR><TR CLASS="z"><TD CLASS="l">235</TD><TD>        } catch (ChannelException x) {</TD></TR><TR CLASS="z"><TD CLASS="l">236</TD><TD>            log.warn(&#34;Unable to send map start message.&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">237</TD><TD>            if (terminate) {</TD></TR><TR CLASS="z"><TD CLASS="l">238</TD><TD>                breakdown();</TD></TR><TR CLASS="z"><TD CLASS="l">239</TD><TD>                throw new RuntimeException(&#34;Unable to start replicated map.&#34;,x);</TD></TR><TR><TD CLASS="l">240</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">241</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">242</TD><TD>        long complete = System.currentTimeMillis() - start;</TD></TR><TR CLASS="z"><TD CLASS="l">243</TD><TD>        if (log.isInfoEnabled())</TD></TR><TR CLASS="z"><TD CLASS="l">244</TD><TD>            log.info(&#34;AbstractReplicatedMap[&#34; +mapContextName + &#34;] initialization was completed in &#34; + complete + &#34; ms.&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">245</TD><TD>    }</TD></TR><TR><TD CLASS="l">246</TD><TD> </TD></TR><TR><TD CLASS="l">247</TD><TD> </TD></TR><TR><TD CLASS="l">248</TD><TD>    /**</TD></TR><TR><TD CLASS="l">249</TD><TD>     * Sends a ping out to all the members in the cluster, not just map members</TD></TR><TR><TD CLASS="l">250</TD><TD>     * that this map is alive.</TD></TR><TR><TD CLASS="l">251</TD><TD>     * @param timeout long</TD></TR><TR><TD CLASS="l"><A NAME="2d">252</A></TD><TD>     * @throws ChannelException</TD></TR><TR><TD CLASS="l">253</TD><TD>     */</TD></TR><TR><TD CLASS="l">254</TD><TD>    protected void ping(long timeout) throws ChannelException {</TD></TR><TR><TD CLASS="l">255</TD><TD>        //send out a map membership message, only wait for the first reply</TD></TR><TR CLASS="z"><TD CLASS="l">256</TD><TD>        MapMessage msg = new MapMessage(this.mapContextName,</TD></TR><TR><TD CLASS="l">257</TD><TD>                                        MapMessage.MSG_INIT,</TD></TR><TR><TD CLASS="l">258</TD><TD>                                        false,</TD></TR><TR><TD CLASS="l">259</TD><TD>                                        null,</TD></TR><TR><TD CLASS="l">260</TD><TD>                                        null,</TD></TR><TR><TD CLASS="l">261</TD><TD>                                        null,</TD></TR><TR CLASS="z"><TD CLASS="l">262</TD><TD>                                        channel.getLocalMember(false),</TD></TR><TR><TD CLASS="l">263</TD><TD>                                        null);</TD></TR><TR CLASS="z"><TD CLASS="l">264</TD><TD>        if ( channel.getMembers().length &gt; 0 ) {</TD></TR><TR><TD CLASS="l">265</TD><TD>            try {</TD></TR><TR><TD CLASS="l">266</TD><TD>                //send a ping, wait for all nodes to reply</TD></TR><TR CLASS="z"><TD CLASS="l">267</TD><TD>                Response[] resp = rpcChannel.send(channel.getMembers(),</TD></TR><TR><TD CLASS="l">268</TD><TD>                                                  msg, RpcChannel.ALL_REPLY,</TD></TR><TR><TD CLASS="l">269</TD><TD>                                                  (channelSendOptions),</TD></TR><TR><TD CLASS="l">270</TD><TD>                                                  (int) accessTimeout);</TD></TR><TR CLASS="z"><TD CLASS="l">271</TD><TD>                for (int i = 0; i &lt; resp.length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">272</TD><TD>                    memberAlive(resp[i].getSource());</TD></TR><TR><TD CLASS="l">273</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">274</TD><TD>            } catch (ChannelException ce) {</TD></TR><TR><TD CLASS="l">275</TD><TD>                // Handle known failed members</TD></TR><TR CLASS="z"><TD CLASS="l">276</TD><TD>                FaultyMember[] faultyMembers = ce.getFaultyMembers();</TD></TR><TR CLASS="z"><TD CLASS="l">277</TD><TD>                for (FaultyMember faultyMember : faultyMembers) {</TD></TR><TR CLASS="z"><TD CLASS="l">278</TD><TD>                    memberDisappeared(faultyMember.getMember());</TD></TR><TR><TD CLASS="l">279</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">280</TD><TD>                throw ce;</TD></TR><TR CLASS="z"><TD CLASS="l">281</TD><TD>            }</TD></TR><TR><TD CLASS="l">282</TD><TD>        }</TD></TR><TR><TD CLASS="l">283</TD><TD>        //update our map of members, expire some if we didn't receive a ping back</TD></TR><TR CLASS="z"><TD CLASS="l">284</TD><TD>        synchronized (mapMembers) {</TD></TR><TR CLASS="z"><TD CLASS="l">285</TD><TD>            Member[] members = mapMembers.keySet().toArray(new Member[mapMembers.size()]);</TD></TR><TR CLASS="z"><TD CLASS="l">286</TD><TD>            long now = System.currentTimeMillis();</TD></TR><TR CLASS="z"><TD CLASS="l">287</TD><TD>            for (Member member : members) {</TD></TR><TR CLASS="z"><TD CLASS="l">288</TD><TD>                long access = mapMembers.get(member).longValue();</TD></TR><TR CLASS="z"><TD CLASS="l">289</TD><TD>                if ( (now - access) &gt; timeout ) {</TD></TR><TR CLASS="z"><TD CLASS="l">290</TD><TD>                    memberDisappeared(member);</TD></TR><TR><TD CLASS="l">291</TD><TD>                }</TD></TR><TR><TD CLASS="l">292</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">293</TD><TD>        }//synch</TD></TR><TR CLASS="z"><TD CLASS="l">294</TD><TD>    }</TD></TR><TR><TD CLASS="l">295</TD><TD> </TD></TR><TR><TD CLASS="l">296</TD><TD>    /**</TD></TR><TR><TD CLASS="l"><A NAME="2a">297</A></TD><TD>     * We have received a member alive notification</TD></TR><TR><TD CLASS="l">298</TD><TD>     * @param member Member</TD></TR><TR><TD CLASS="l">299</TD><TD>     */</TD></TR><TR><TD CLASS="l">300</TD><TD>    protected void memberAlive(Member member) {</TD></TR><TR CLASS="z"><TD CLASS="l">301</TD><TD>        synchronized (mapMembers) {</TD></TR><TR CLASS="z"><TD CLASS="l">302</TD><TD>            if (!mapMembers.containsKey(member)) {</TD></TR><TR CLASS="z"><TD CLASS="l">303</TD><TD>                mapMemberAdded(member);</TD></TR><TR><TD CLASS="l">304</TD><TD>            } //end if</TD></TR><TR CLASS="z"><TD CLASS="l">305</TD><TD>            mapMembers.put(member, new Long(System.currentTimeMillis()));</TD></TR><TR CLASS="z"><TD CLASS="l">306</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">307</TD><TD>    }</TD></TR><TR><TD CLASS="l">308</TD><TD> </TD></TR><TR><TD CLASS="l">309</TD><TD>    /**</TD></TR><TR><TD CLASS="l">310</TD><TD>     * Helper method to broadcast a message to all members in a channel</TD></TR><TR><TD CLASS="l">311</TD><TD>     * @param msgtype int</TD></TR><TR><TD CLASS="l"><A NAME="4">312</A></TD><TD>     * @param rpc boolean</TD></TR><TR><TD CLASS="l">313</TD><TD>     * @throws ChannelException</TD></TR><TR><TD CLASS="l">314</TD><TD>     */</TD></TR><TR><TD CLASS="l">315</TD><TD>    protected void broadcast(int msgtype, boolean rpc) throws ChannelException {</TD></TR><TR CLASS="z"><TD CLASS="l">316</TD><TD>        Member[] members = channel.getMembers();</TD></TR><TR><TD CLASS="l">317</TD><TD>        // No destination.</TD></TR><TR CLASS="z"><TD CLASS="l">318</TD><TD>        if (members.length == 0 ) return;</TD></TR><TR><TD CLASS="l">319</TD><TD>        //send out a map membership message, only wait for the first reply</TD></TR><TR CLASS="z"><TD CLASS="l">320</TD><TD>        MapMessage msg = new MapMessage(this.mapContextName, msgtype,</TD></TR><TR CLASS="z"><TD CLASS="l">321</TD><TD>                                        false, null, null, null, channel.getLocalMember(false), null);</TD></TR><TR CLASS="z"><TD CLASS="l">322</TD><TD>        if ( rpc) {</TD></TR><TR CLASS="z"><TD CLASS="l">323</TD><TD>            Response[] resp = rpcChannel.send(members, msg,</TD></TR><TR><TD CLASS="l">324</TD><TD>                    RpcChannel.FIRST_REPLY, (channelSendOptions), rpcTimeout);</TD></TR><TR CLASS="z"><TD CLASS="l">325</TD><TD>            if (resp.length &gt; 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">326</TD><TD>                for (int i = 0; i &lt; resp.length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">327</TD><TD>                    mapMemberAdded(resp[i].getSource());</TD></TR><TR CLASS="z"><TD CLASS="l">328</TD><TD>                    messageReceived(resp[i].getMessage(), resp[i].getSource());</TD></TR><TR><TD CLASS="l">329</TD><TD>                }</TD></TR><TR><TD CLASS="l">330</TD><TD>            } else {</TD></TR><TR CLASS="z"><TD CLASS="l">331</TD><TD>                log.warn(&#34;broadcast received 0 replies, probably a timeout.&#34;);</TD></TR><TR><TD CLASS="l">332</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">333</TD><TD>        } else {</TD></TR><TR CLASS="z"><TD CLASS="l">334</TD><TD>            channel.send(channel.getMembers(),msg,channelSendOptions);</TD></TR><TR><TD CLASS="l"><A NAME="3">335</A></TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">336</TD><TD>    }</TD></TR><TR><TD CLASS="l">337</TD><TD> </TD></TR><TR><TD CLASS="l">338</TD><TD>    public void breakdown() {</TD></TR><TR CLASS="z"><TD CLASS="l">339</TD><TD>        finalize();</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="e">340</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">341</TD><TD> </TD></TR><TR><TD CLASS="l">342</TD><TD>    @Override</TD></TR><TR><TD CLASS="l">343</TD><TD>    public void finalize() {</TD></TR><TR CLASS="z"><TD CLASS="l">344</TD><TD>        if (this.rpcChannel != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">345</TD><TD>            this.rpcChannel.breakdown();</TD></TR><TR><TD CLASS="l">346</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">347</TD><TD>        try {broadcast(MapMessage.MSG_STOP,false); }catch ( Exception ignore){}</TD></TR><TR><TD CLASS="l">348</TD><TD>        //cleanup</TD></TR><TR CLASS="z"><TD CLASS="l">349</TD><TD>        if (this.channel != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">350</TD><TD>            this.channel.removeChannelListener(this);</TD></TR><TR CLASS="z"><TD CLASS="l">351</TD><TD>            this.channel.removeMembershipListener(this);</TD></TR><TR><TD CLASS="l">352</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">353</TD><TD>        this.rpcChannel = null;</TD></TR><TR CLASS="z"><TD CLASS="l">354</TD><TD>        this.channel = null;</TD></TR><TR CLASS="z"><TD CLASS="l">355</TD><TD>        this.mapMembers.clear();</TD></TR><TR CLASS="z"><TD CLASS="l">356</TD><TD>        innerMap.clear();</TD></TR><TR CLASS="z"><TD CLASS="l">357</TD><TD>        this.stateTransferred = false;</TD></TR><TR CLASS="z"><TD CLASS="l">358</TD><TD>        this.externalLoaders = null;</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="1f">359</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">360</TD><TD> </TD></TR><TR><TD CLASS="l">361</TD><TD>    @Override</TD></TR><TR><TD CLASS="l">362</TD><TD>    public int hashCode() {</TD></TR><TR CLASS="z"><TD CLASS="l">363</TD><TD>        return Arrays.hashCode(this.mapContextName);</TD></TR><TR><TD CLASS="l"><A NAME="c">364</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">365</TD><TD> </TD></TR><TR><TD CLASS="l">366</TD><TD>    @Override</TD></TR><TR><TD CLASS="l">367</TD><TD>    public boolean equals(Object o) {</TD></TR><TR CLASS="z"><TD CLASS="l">368</TD><TD>        if ( !(o instanceof AbstractReplicatedMap)) return false;</TD></TR><TR CLASS="z"><TD CLASS="l">369</TD><TD>        if ( !(o.getClass().equals(this.getClass())) ) return false;</TD></TR><TR><TD CLASS="l">370</TD><TD>        @SuppressWarnings(&#34;unchecked&#34;)</TD></TR><TR CLASS="z"><TD CLASS="l">371</TD><TD>        AbstractReplicatedMap&lt;K,V&gt; other = (AbstractReplicatedMap&lt;K,V&gt;)o;</TD></TR><TR CLASS="z"><TD CLASS="l">372</TD><TD>        return Arrays.equals(mapContextName,other.mapContextName);</TD></TR><TR><TD CLASS="l">373</TD><TD>    }</TD></TR><TR><TD CLASS="l">374</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="17">375</A></TD><TD>//------------------------------------------------------------------------------</TD></TR><TR><TD CLASS="l">376</TD><TD>//              GROUP COM INTERFACES</TD></TR><TR><TD CLASS="l">377</TD><TD>//------------------------------------------------------------------------------</TD></TR><TR><TD CLASS="l">378</TD><TD>    public Member[] getMapMembers(HashMap&lt;Member, Long&gt; members) {</TD></TR><TR CLASS="z"><TD CLASS="l">379</TD><TD>        synchronized (members) {</TD></TR><TR CLASS="z"><TD CLASS="l">380</TD><TD>            Member[] result = new Member[members.size()];</TD></TR><TR CLASS="z"><TD CLASS="l">381</TD><TD>            members.keySet().toArray(result);</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="16">382</A></TD><TD>            return result;</TD></TR><TR CLASS="z"><TD CLASS="l">383</TD><TD>        }</TD></TR><TR><TD CLASS="l">384</TD><TD>    }</TD></TR><TR><TD CLASS="l">385</TD><TD>    public Member[] getMapMembers() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="18">386</A></TD><TD>        return getMapMembers(this.mapMembers);</TD></TR><TR><TD CLASS="l">387</TD><TD>    }</TD></TR><TR><TD CLASS="l">388</TD><TD> </TD></TR><TR><TD CLASS="l">389</TD><TD>    public Member[] getMapMembersExcl(Member[] exclude) {</TD></TR><TR CLASS="z"><TD CLASS="l">390</TD><TD>        synchronized (mapMembers) {</TD></TR><TR><TD CLASS="l">391</TD><TD>            @SuppressWarnings(&#34;unchecked&#34;) // mapMembers has the correct type</TD></TR><TR CLASS="z"><TD CLASS="l">392</TD><TD>            HashMap&lt;Member, Long&gt; list = (HashMap&lt;Member, Long&gt;)mapMembers.clone();</TD></TR><TR CLASS="z"><TD CLASS="l">393</TD><TD>            for (int i=0; i&lt;exclude.length;i++) list.remove(exclude[i]);</TD></TR><TR CLASS="z"><TD CLASS="l">394</TD><TD>            return getMapMembers(list);</TD></TR><TR CLASS="z"><TD CLASS="l">395</TD><TD>        }</TD></TR><TR><TD CLASS="l">396</TD><TD>    }</TD></TR><TR><TD CLASS="l">397</TD><TD> </TD></TR><TR><TD CLASS="l">398</TD><TD> </TD></TR><TR><TD CLASS="l">399</TD><TD>    /**</TD></TR><TR><TD CLASS="l">400</TD><TD>     * Replicates any changes to the object since the last time</TD></TR><TR><TD CLASS="l">401</TD><TD>     * The object has to be primary, ie, if the object is a proxy or a backup, it will not be replicated&lt;br&gt;</TD></TR><TR><TD CLASS="l">402</TD><TD>     * @param complete - if set to true, the object is replicated to its backup</TD></TR><TR><TD CLASS="l"><A NAME="34">403</A></TD><TD>     * if set to false, only objects that implement ReplicatedMapEntry and the isDirty() returns true will</TD></TR><TR><TD CLASS="l">404</TD><TD>     * be replicated</TD></TR><TR><TD CLASS="l">405</TD><TD>     */</TD></TR><TR><TD CLASS="l">406</TD><TD>    public void replicate(Object key, boolean complete) {</TD></TR><TR CLASS="z"><TD CLASS="l">407</TD><TD>        if ( log.isTraceEnabled() )</TD></TR><TR CLASS="z"><TD CLASS="l">408</TD><TD>            log.trace(&#34;Replicate invoked on key:&#34;+key);</TD></TR><TR CLASS="z"><TD CLASS="l">409</TD><TD>        MapEntry&lt;K,V&gt; entry = innerMap.get(key);</TD></TR><TR CLASS="z"><TD CLASS="l">410</TD><TD>        if ( entry == null ) return;</TD></TR><TR CLASS="z"><TD CLASS="l">411</TD><TD>        if ( !entry.isSerializable() ) return;</TD></TR><TR CLASS="z"><TD CLASS="l">412</TD><TD>        if (entry.isPrimary() &amp;&amp; entry.getBackupNodes()!= null &amp;&amp; entry.getBackupNodes().length &gt; 0) {</TD></TR><TR><TD CLASS="l">413</TD><TD>            //check to see if we need to replicate this object isDirty()||complete</TD></TR><TR CLASS="z"><TD CLASS="l">414</TD><TD>            ReplicatedMapEntry rentry = null;</TD></TR><TR CLASS="z"><TD CLASS="l">415</TD><TD>            if (entry.getValue() instanceof ReplicatedMapEntry) rentry = (ReplicatedMapEntry)entry.getValue();</TD></TR><TR CLASS="z"><TD CLASS="l">416</TD><TD>            boolean isDirty = rentry != null &amp;&amp; rentry.isDirty();</TD></TR><TR CLASS="z"><TD CLASS="l">417</TD><TD>            boolean repl = complete || isDirty;</TD></TR><TR><TD CLASS="l">418</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">419</TD><TD>            if (!repl) {</TD></TR><TR CLASS="z"><TD CLASS="l">420</TD><TD>                if ( log.isTraceEnabled() )</TD></TR><TR CLASS="z"><TD CLASS="l">421</TD><TD>                    log.trace(&#34;Not replicating:&#34;+key+&#34;, no change made&#34;);</TD></TR><TR><TD CLASS="l">422</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">423</TD><TD>                return;</TD></TR><TR><TD CLASS="l">424</TD><TD>            }</TD></TR><TR><TD CLASS="l">425</TD><TD>            //check to see if the message is diffable</TD></TR><TR CLASS="z"><TD CLASS="l">426</TD><TD>            MapMessage msg = null;</TD></TR><TR CLASS="z"><TD CLASS="l">427</TD><TD>            if (rentry != null &amp;&amp; rentry.isDiffable() &amp;&amp; (isDirty || complete)) {</TD></TR><TR CLASS="z"><TD CLASS="l">428</TD><TD>                rentry.lock();</TD></TR><TR><TD CLASS="l">429</TD><TD>                try {</TD></TR><TR><TD CLASS="l">430</TD><TD>                    //construct a diff message</TD></TR><TR CLASS="z"><TD CLASS="l">431</TD><TD>                    msg = new MapMessage(mapContextName, MapMessage.MSG_BACKUP,</TD></TR><TR CLASS="z"><TD CLASS="l">432</TD><TD>                                         true, (Serializable) entry.getKey(), null,</TD></TR><TR CLASS="z"><TD CLASS="l">433</TD><TD>                                         rentry.getDiff(),</TD></TR><TR CLASS="z"><TD CLASS="l">434</TD><TD>                                         entry.getPrimary(),</TD></TR><TR CLASS="z"><TD CLASS="l">435</TD><TD>                                         entry.getBackupNodes());</TD></TR><TR CLASS="z"><TD CLASS="l">436</TD><TD>                    rentry.resetDiff();</TD></TR><TR CLASS="z"><TD CLASS="l">437</TD><TD>                } catch (IOException x) {</TD></TR><TR CLASS="z"><TD CLASS="l">438</TD><TD>                    log.error(&#34;Unable to diff object. Will replicate the entire object instead.&#34;, x);</TD></TR><TR CLASS="z"><TD CLASS="l">439</TD><TD>                } finally {</TD></TR><TR CLASS="z"><TD CLASS="l">440</TD><TD>                    rentry.unlock();</TD></TR><TR CLASS="z"><TD CLASS="l">441</TD><TD>                }</TD></TR><TR><TD CLASS="l">442</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">443</TD><TD>            if (msg == null &amp;&amp; complete) {</TD></TR><TR><TD CLASS="l">444</TD><TD>                //construct a complete</TD></TR><TR CLASS="z"><TD CLASS="l">445</TD><TD>                msg = new MapMessage(mapContextName, MapMessage.MSG_BACKUP,</TD></TR><TR CLASS="z"><TD CLASS="l">446</TD><TD>                                     false, (Serializable) entry.getKey(),</TD></TR><TR CLASS="z"><TD CLASS="l">447</TD><TD>                                     (Serializable) entry.getValue(),</TD></TR><TR CLASS="z"><TD CLASS="l">448</TD><TD>                                     null, entry.getPrimary(),entry.getBackupNodes());</TD></TR><TR><TD CLASS="l">449</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">450</TD><TD>            if (msg == null) {</TD></TR><TR><TD CLASS="l">451</TD><TD>                //construct a access message</TD></TR><TR CLASS="z"><TD CLASS="l">452</TD><TD>                msg = new MapMessage(mapContextName, MapMessage.MSG_ACCESS,</TD></TR><TR CLASS="z"><TD CLASS="l">453</TD><TD>                        false, (Serializable) entry.getKey(), null, null, entry.getPrimary(),</TD></TR><TR CLASS="z"><TD CLASS="l">454</TD><TD>                        entry.getBackupNodes());</TD></TR><TR><TD CLASS="l">455</TD><TD>            }</TD></TR><TR><TD CLASS="l">456</TD><TD>            try {</TD></TR><TR CLASS="z"><TD CLASS="l">457</TD><TD>                if ( channel!=null &amp;&amp; entry.getBackupNodes()!= null &amp;&amp; entry.getBackupNodes().length &gt; 0 ) {</TD></TR><TR CLASS="z"><TD CLASS="l">458</TD><TD>                    channel.send(entry.getBackupNodes(), msg, channelSendOptions);</TD></TR><TR><TD CLASS="l">459</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">460</TD><TD>            } catch (ChannelException x) {</TD></TR><TR CLASS="z"><TD CLASS="l">461</TD><TD>                log.error(&#34;Unable to replicate data.&#34;, x);</TD></TR><TR CLASS="z"><TD CLASS="l">462</TD><TD>            }</TD></TR><TR><TD CLASS="l">463</TD><TD>        } //end if</TD></TR><TR><TD CLASS="l">464</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">465</TD><TD>    }</TD></TR><TR><TD CLASS="l">466</TD><TD> </TD></TR><TR><TD CLASS="l">467</TD><TD>    /**</TD></TR><TR><TD CLASS="l">468</TD><TD>     * This can be invoked by a periodic thread to replicate out any changes.</TD></TR><TR><TD CLASS="l">469</TD><TD>     * For maps that don't store objects that implement ReplicatedMapEntry, this</TD></TR><TR><TD CLASS="l"><A NAME="35">470</A></TD><TD>     * method should be used infrequently to avoid large amounts of data transfer</TD></TR><TR><TD CLASS="l">471</TD><TD>     * @param complete boolean</TD></TR><TR><TD CLASS="l">472</TD><TD>     */</TD></TR><TR><TD CLASS="l">473</TD><TD>    public void replicate(boolean complete) {</TD></TR><TR CLASS="z"><TD CLASS="l">474</TD><TD>        Iterator&lt;Map.Entry&lt;K,MapEntry&lt;K,V&gt;&gt;&gt; i = innerMap.entrySet().iterator();</TD></TR><TR CLASS="z"><TD CLASS="l">475</TD><TD>        while (i.hasNext()) {</TD></TR><TR CLASS="z"><TD CLASS="l">476</TD><TD>            Map.Entry&lt;?,?&gt; e = i.next();</TD></TR><TR CLASS="z"><TD CLASS="l">477</TD><TD>            replicate(e.getKey(), complete);</TD></TR><TR CLASS="z"><TD CLASS="l">478</TD><TD>        } //while</TD></TR><TR><TD CLASS="l">479</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="3d">480</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">481</TD><TD> </TD></TR><TR><TD CLASS="l">482</TD><TD>    public void transferState() {</TD></TR><TR><TD CLASS="l">483</TD><TD>        try {</TD></TR><TR CLASS="z"><TD CLASS="l">484</TD><TD>            Member[] members = getMapMembers();</TD></TR><TR CLASS="z"><TD CLASS="l">485</TD><TD>            Member backup = members.length &gt; 0 ? (Member) members[0] : null;</TD></TR><TR CLASS="z"><TD CLASS="l">486</TD><TD>            if (backup != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">487</TD><TD>                MapMessage msg = new MapMessage(mapContextName, getStateMessageType(), false,</TD></TR><TR><TD CLASS="l">488</TD><TD>                                                null, null, null, null, null);</TD></TR><TR CLASS="z"><TD CLASS="l">489</TD><TD>                Response[] resp = rpcChannel.send(new Member[] {backup}, msg, RpcChannel.FIRST_REPLY, channelSendOptions, rpcTimeout);</TD></TR><TR CLASS="z"><TD CLASS="l">490</TD><TD>                if (resp.length &gt; 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">491</TD><TD>                    synchronized (stateMutex) {</TD></TR><TR CLASS="z"><TD CLASS="l">492</TD><TD>                        msg = (MapMessage) resp[0].getMessage();</TD></TR><TR CLASS="z"><TD CLASS="l">493</TD><TD>                        msg.deserialize(getExternalLoaders());</TD></TR><TR CLASS="z"><TD CLASS="l">494</TD><TD>                        ArrayList&lt;?&gt; list = (ArrayList&lt;?&gt;) msg.getValue();</TD></TR><TR CLASS="z"><TD CLASS="l">495</TD><TD>                        for (int i = 0; i &lt; list.size(); i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">496</TD><TD>                            messageReceived( (Serializable) list.get(i), resp[0].getSource());</TD></TR><TR><TD CLASS="l">497</TD><TD>                        } //for</TD></TR><TR CLASS="z"><TD CLASS="l">498</TD><TD>                    }</TD></TR><TR><TD CLASS="l">499</TD><TD>                } else {</TD></TR><TR CLASS="z"><TD CLASS="l">500</TD><TD>                    log.warn(&#34;Transfer state, 0 replies, probably a timeout.&#34;);</TD></TR><TR><TD CLASS="l">501</TD><TD>                }</TD></TR><TR><TD CLASS="l">502</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">503</TD><TD>        } catch (ChannelException x) {</TD></TR><TR CLASS="z"><TD CLASS="l">504</TD><TD>            log.error(&#34;Unable to transfer LazyReplicatedMap state.&#34;, x);</TD></TR><TR CLASS="z"><TD CLASS="l">505</TD><TD>        } catch (IOException x) {</TD></TR><TR CLASS="z"><TD CLASS="l">506</TD><TD>            log.error(&#34;Unable to transfer LazyReplicatedMap state.&#34;, x);</TD></TR><TR CLASS="z"><TD CLASS="l">507</TD><TD>        } catch (ClassNotFoundException x) {</TD></TR><TR CLASS="z"><TD CLASS="l">508</TD><TD>            log.error(&#34;Unable to transfer LazyReplicatedMap state.&#34;, x);</TD></TR><TR CLASS="z"><TD CLASS="l">509</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">510</TD><TD>        stateTransferred = true;</TD></TR><TR CLASS="z"><TD CLASS="l">511</TD><TD>    }</TD></TR><TR><TD CLASS="l">512</TD><TD> </TD></TR><TR><TD CLASS="l">513</TD><TD>    /**</TD></TR><TR><TD CLASS="l">514</TD><TD>     * TODO implement state transfer</TD></TR><TR><TD CLASS="l"><A NAME="36">515</A></TD><TD>     * @param msg Serializable</TD></TR><TR><TD CLASS="l">516</TD><TD>     * @return Serializable - null if no reply should be sent</TD></TR><TR><TD CLASS="l">517</TD><TD>     */</TD></TR><TR><TD CLASS="l">518</TD><TD>    public Serializable replyRequest(Serializable msg, final Member sender) {</TD></TR><TR CLASS="z"><TD CLASS="l">519</TD><TD>        if (! (msg instanceof MapMessage))return null;</TD></TR><TR CLASS="z"><TD CLASS="l">520</TD><TD>        MapMessage mapmsg = (MapMessage) msg;</TD></TR><TR><TD CLASS="l">521</TD><TD> </TD></TR><TR><TD CLASS="l">522</TD><TD>        //map init request</TD></TR><TR CLASS="z"><TD CLASS="l">523</TD><TD>        if (mapmsg.getMsgType() == MapMessage.MSG_INIT) {</TD></TR><TR CLASS="z"><TD CLASS="l">524</TD><TD>            mapmsg.setPrimary(channel.getLocalMember(false));</TD></TR><TR CLASS="z"><TD CLASS="l">525</TD><TD>            return mapmsg;</TD></TR><TR><TD CLASS="l">526</TD><TD>        }</TD></TR><TR><TD CLASS="l">527</TD><TD> </TD></TR><TR><TD CLASS="l">528</TD><TD>        //map start request</TD></TR><TR CLASS="z"><TD CLASS="l">529</TD><TD>        if (mapmsg.getMsgType() == MapMessage.MSG_START) {</TD></TR><TR CLASS="z"><TD CLASS="l">530</TD><TD>            mapmsg.setPrimary(channel.getLocalMember(false));</TD></TR><TR CLASS="z"><TD CLASS="l">531</TD><TD>            mapMemberAdded(sender);</TD></TR><TR CLASS="z"><TD CLASS="l">532</TD><TD>            return mapmsg;</TD></TR><TR><TD CLASS="l">533</TD><TD>        }</TD></TR><TR><TD CLASS="l">534</TD><TD> </TD></TR><TR><TD CLASS="l">535</TD><TD>        //backup request</TD></TR><TR CLASS="z"><TD CLASS="l">536</TD><TD>        if (mapmsg.getMsgType() == MapMessage.MSG_RETRIEVE_BACKUP) {</TD></TR><TR CLASS="z"><TD CLASS="l">537</TD><TD>            MapEntry&lt;K,V&gt; entry = innerMap.get(mapmsg.getKey());</TD></TR><TR CLASS="z"><TD CLASS="l">538</TD><TD>            if (entry == null || (!entry.isSerializable()) )return null;</TD></TR><TR CLASS="z"><TD CLASS="l">539</TD><TD>            mapmsg.setValue( (Serializable) entry.getValue());</TD></TR><TR CLASS="z"><TD CLASS="l">540</TD><TD>            return mapmsg;</TD></TR><TR><TD CLASS="l">541</TD><TD>        }</TD></TR><TR><TD CLASS="l">542</TD><TD> </TD></TR><TR><TD CLASS="l">543</TD><TD>        //state transfer request</TD></TR><TR CLASS="z"><TD CLASS="l">544</TD><TD>        if (mapmsg.getMsgType() == MapMessage.MSG_STATE || mapmsg.getMsgType() == MapMessage.MSG_STATE_COPY) {</TD></TR><TR CLASS="z"><TD CLASS="l">545</TD><TD>            synchronized (stateMutex) { //make sure we dont do two things at the same time</TD></TR><TR CLASS="z"><TD CLASS="l">546</TD><TD>                ArrayList&lt;MapMessage&gt; list = new ArrayList&lt;MapMessage&gt;();</TD></TR><TR CLASS="z"><TD CLASS="l">547</TD><TD>                Iterator&lt;Map.Entry&lt;K,MapEntry&lt;K,V&gt;&gt;&gt; i = innerMap.entrySet().iterator();</TD></TR><TR CLASS="z"><TD CLASS="l">548</TD><TD>                while (i.hasNext()) {</TD></TR><TR CLASS="z"><TD CLASS="l">549</TD><TD>                    Map.Entry&lt;?,?&gt; e = i.next();</TD></TR><TR CLASS="z"><TD CLASS="l">550</TD><TD>                    MapEntry&lt;K,V&gt; entry = innerMap.get(e.getKey());</TD></TR><TR CLASS="z"><TD CLASS="l">551</TD><TD>                    if ( entry != null &amp;&amp; entry.isSerializable() ) {</TD></TR><TR CLASS="z"><TD CLASS="l">552</TD><TD>                        boolean copy = (mapmsg.getMsgType() == MapMessage.MSG_STATE_COPY);</TD></TR><TR CLASS="z"><TD CLASS="l">553</TD><TD>                        MapMessage me = new MapMessage(mapContextName,</TD></TR><TR><TD CLASS="l">554</TD><TD>                                                       copy?MapMessage.MSG_COPY:MapMessage.MSG_PROXY,</TD></TR><TR CLASS="z"><TD CLASS="l">555</TD><TD>                            false, (Serializable) entry.getKey(), copy?(Serializable) entry.getValue():null, null, entry.getPrimary(),entry.getBackupNodes());</TD></TR><TR CLASS="z"><TD CLASS="l">556</TD><TD>                        list.add(me);</TD></TR><TR><TD CLASS="l">557</TD><TD>                    }</TD></TR><TR CLASS="z"><TD CLASS="l">558</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">559</TD><TD>                mapmsg.setValue(list);</TD></TR><TR CLASS="z"><TD CLASS="l">560</TD><TD>                return mapmsg;</TD></TR><TR><TD CLASS="l">561</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">562</TD><TD>            } //synchronized</TD></TR><TR><TD CLASS="l">563</TD><TD>        }</TD></TR><TR><TD CLASS="l">564</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">565</TD><TD>        return null;</TD></TR><TR><TD CLASS="l">566</TD><TD> </TD></TR><TR><TD CLASS="l">567</TD><TD>    }</TD></TR><TR><TD CLASS="l">568</TD><TD> </TD></TR><TR><TD CLASS="l">569</TD><TD>    /**</TD></TR><TR><TD CLASS="l">570</TD><TD>     * If the reply has already been sent to the requesting thread,</TD></TR><TR><TD CLASS="l">571</TD><TD>     * the rpc callback can handle any data that comes in after the fact.</TD></TR><TR><TD CLASS="l">572</TD><TD>     * @param msg Serializable</TD></TR><TR><TD CLASS="l"><A NAME="27">573</A></TD><TD>     * @param sender Member</TD></TR><TR><TD CLASS="l">574</TD><TD>     */</TD></TR><TR><TD CLASS="l">575</TD><TD>    public void leftOver(Serializable msg, Member sender) {</TD></TR><TR><TD CLASS="l">576</TD><TD>        //left over membership messages</TD></TR><TR CLASS="z"><TD CLASS="l">577</TD><TD>        if (! (msg instanceof MapMessage))return;</TD></TR><TR><TD CLASS="l">578</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">579</TD><TD>        MapMessage mapmsg = (MapMessage) msg;</TD></TR><TR><TD CLASS="l">580</TD><TD>        try {</TD></TR><TR CLASS="z"><TD CLASS="l">581</TD><TD>            mapmsg.deserialize(getExternalLoaders());</TD></TR><TR CLASS="z"><TD CLASS="l">582</TD><TD>            if (mapmsg.getMsgType() == MapMessage.MSG_START) {</TD></TR><TR CLASS="z"><TD CLASS="l">583</TD><TD>                mapMemberAdded(mapmsg.getPrimary());</TD></TR><TR CLASS="z"><TD CLASS="l">584</TD><TD>            } else if (mapmsg.getMsgType() == MapMessage.MSG_INIT) {</TD></TR><TR CLASS="z"><TD CLASS="l">585</TD><TD>                memberAlive(mapmsg.getPrimary());</TD></TR><TR><TD CLASS="l">586</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">587</TD><TD>        } catch (IOException x ) {</TD></TR><TR CLASS="z"><TD CLASS="l">588</TD><TD>            log.error(&#34;Unable to deserialize MapMessage.&#34;,x);</TD></TR><TR CLASS="z"><TD CLASS="l">589</TD><TD>        } catch (ClassNotFoundException x ) {</TD></TR><TR CLASS="z"><TD CLASS="l">590</TD><TD>            log.error(&#34;Unable to deserialize MapMessage.&#34;,x);</TD></TR><TR CLASS="z"><TD CLASS="l">591</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="2c">592</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">593</TD><TD> </TD></TR><TR><TD CLASS="l">594</TD><TD>    @SuppressWarnings(&#34;unchecked&#34;)</TD></TR><TR><TD CLASS="l">595</TD><TD>    public void messageReceived(Serializable msg, Member sender) {</TD></TR><TR CLASS="z"><TD CLASS="l">596</TD><TD>        if (! (msg instanceof MapMessage)) return;</TD></TR><TR><TD CLASS="l">597</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">598</TD><TD>        MapMessage mapmsg = (MapMessage) msg;</TD></TR><TR CLASS="z"><TD CLASS="l">599</TD><TD>        if ( log.isTraceEnabled() ) {</TD></TR><TR CLASS="z"><TD CLASS="l">600</TD><TD>            log.trace(&#34;Map[&#34;+mapname+&#34;] received message:&#34;+mapmsg);</TD></TR><TR><TD CLASS="l">601</TD><TD>        }</TD></TR><TR><TD CLASS="l">602</TD><TD> </TD></TR><TR><TD CLASS="l">603</TD><TD>        try {</TD></TR><TR CLASS="z"><TD CLASS="l">604</TD><TD>            mapmsg.deserialize(getExternalLoaders());</TD></TR><TR CLASS="z"><TD CLASS="l">605</TD><TD>        } catch (IOException x) {</TD></TR><TR CLASS="z"><TD CLASS="l">606</TD><TD>            log.error(&#34;Unable to deserialize MapMessage.&#34;, x);</TD></TR><TR CLASS="z"><TD CLASS="l">607</TD><TD>            return;</TD></TR><TR CLASS="z"><TD CLASS="l">608</TD><TD>        } catch (ClassNotFoundException x) {</TD></TR><TR CLASS="z"><TD CLASS="l">609</TD><TD>            log.error(&#34;Unable to deserialize MapMessage.&#34;, x);</TD></TR><TR CLASS="z"><TD CLASS="l">610</TD><TD>            return;</TD></TR><TR CLASS="z"><TD CLASS="l">611</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">612</TD><TD>        if ( log.isTraceEnabled() )</TD></TR><TR CLASS="z"><TD CLASS="l">613</TD><TD>            log.trace(&#34;Map message received from:&#34;+sender.getName()+&#34; msg:&#34;+mapmsg);</TD></TR><TR CLASS="z"><TD CLASS="l">614</TD><TD>        if (mapmsg.getMsgType() == MapMessage.MSG_START) {</TD></TR><TR CLASS="z"><TD CLASS="l">615</TD><TD>            mapMemberAdded(mapmsg.getPrimary());</TD></TR><TR><TD CLASS="l">616</TD><TD>        }</TD></TR><TR><TD CLASS="l">617</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">618</TD><TD>        if (mapmsg.getMsgType() == MapMessage.MSG_STOP) {</TD></TR><TR CLASS="z"><TD CLASS="l">619</TD><TD>            memberDisappeared(mapmsg.getPrimary());</TD></TR><TR><TD CLASS="l">620</TD><TD>        }</TD></TR><TR><TD CLASS="l">621</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">622</TD><TD>        if (mapmsg.getMsgType() == MapMessage.MSG_PROXY) {</TD></TR><TR CLASS="z"><TD CLASS="l">623</TD><TD>            MapEntry&lt;K,V&gt; entry = innerMap.get(mapmsg.getKey());</TD></TR><TR CLASS="z"><TD CLASS="l">624</TD><TD>            if ( entry==null ) {</TD></TR><TR CLASS="z"><TD CLASS="l">625</TD><TD>                entry = new MapEntry&lt;K,V&gt;((K) mapmsg.getKey(), (V) mapmsg.getValue());</TD></TR><TR CLASS="z"><TD CLASS="l">626</TD><TD>                MapEntry&lt;K,V&gt; old = innerMap.putIfAbsent(entry.getKey(), entry);</TD></TR><TR CLASS="z"><TD CLASS="l">627</TD><TD>                if (old != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">628</TD><TD>                    entry = old;</TD></TR><TR><TD CLASS="l">629</TD><TD>                }</TD></TR><TR><TD CLASS="l">630</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">631</TD><TD>            entry.setProxy(true);</TD></TR><TR CLASS="z"><TD CLASS="l">632</TD><TD>            entry.setBackup(false);</TD></TR><TR CLASS="z"><TD CLASS="l">633</TD><TD>            entry.setBackupNodes(mapmsg.getBackupNodes());</TD></TR><TR CLASS="z"><TD CLASS="l">634</TD><TD>            entry.setPrimary(mapmsg.getPrimary());</TD></TR><TR><TD CLASS="l">635</TD><TD>        }</TD></TR><TR><TD CLASS="l">636</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">637</TD><TD>        if (mapmsg.getMsgType() == MapMessage.MSG_REMOVE) {</TD></TR><TR CLASS="z"><TD CLASS="l">638</TD><TD>            innerMap.remove(mapmsg.getKey());</TD></TR><TR><TD CLASS="l">639</TD><TD>        }</TD></TR><TR><TD CLASS="l">640</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">641</TD><TD>        if (mapmsg.getMsgType() == MapMessage.MSG_BACKUP || mapmsg.getMsgType() == MapMessage.MSG_COPY) {</TD></TR><TR CLASS="z"><TD CLASS="l">642</TD><TD>            MapEntry&lt;K,V&gt; entry = innerMap.get(mapmsg.getKey());</TD></TR><TR CLASS="z"><TD CLASS="l">643</TD><TD>            if (entry == null) {</TD></TR><TR CLASS="z"><TD CLASS="l">644</TD><TD>                entry = new MapEntry&lt;K,V&gt;((K) mapmsg.getKey(), (V) mapmsg.getValue());</TD></TR><TR CLASS="z"><TD CLASS="l">645</TD><TD>                entry.setBackup(mapmsg.getMsgType() == MapMessage.MSG_BACKUP);</TD></TR><TR CLASS="z"><TD CLASS="l">646</TD><TD>                entry.setProxy(false);</TD></TR><TR CLASS="z"><TD CLASS="l">647</TD><TD>                entry.setBackupNodes(mapmsg.getBackupNodes());</TD></TR><TR CLASS="z"><TD CLASS="l">648</TD><TD>                entry.setPrimary(mapmsg.getPrimary());</TD></TR><TR CLASS="z"><TD CLASS="l">649</TD><TD>                if (mapmsg.getValue()!=null &amp;&amp; mapmsg.getValue() instanceof ReplicatedMapEntry ) {</TD></TR><TR CLASS="z"><TD CLASS="l">650</TD><TD>                    ((ReplicatedMapEntry)mapmsg.getValue()).setOwner(getMapOwner());</TD></TR><TR><TD CLASS="l">651</TD><TD>                }</TD></TR><TR><TD CLASS="l">652</TD><TD>            } else {</TD></TR><TR CLASS="z"><TD CLASS="l">653</TD><TD>                entry.setBackup(mapmsg.getMsgType() == MapMessage.MSG_BACKUP);</TD></TR><TR CLASS="z"><TD CLASS="l">654</TD><TD>                entry.setProxy(false);</TD></TR><TR CLASS="z"><TD CLASS="l">655</TD><TD>                entry.setBackupNodes(mapmsg.getBackupNodes());</TD></TR><TR CLASS="z"><TD CLASS="l">656</TD><TD>                entry.setPrimary(mapmsg.getPrimary());</TD></TR><TR CLASS="z"><TD CLASS="l">657</TD><TD>                if (entry.getValue() instanceof ReplicatedMapEntry) {</TD></TR><TR CLASS="z"><TD CLASS="l">658</TD><TD>                    ReplicatedMapEntry diff = (ReplicatedMapEntry) entry.getValue();</TD></TR><TR CLASS="z"><TD CLASS="l">659</TD><TD>                    if (mapmsg.isDiff()) {</TD></TR><TR CLASS="z"><TD CLASS="l">660</TD><TD>                        diff.lock();</TD></TR><TR><TD CLASS="l">661</TD><TD>                        try {</TD></TR><TR CLASS="z"><TD CLASS="l">662</TD><TD>                            diff.applyDiff(mapmsg.getDiffValue(), 0, mapmsg.getDiffValue().length);</TD></TR><TR CLASS="z"><TD CLASS="l">663</TD><TD>                        } catch (Exception x) {</TD></TR><TR CLASS="z"><TD CLASS="l">664</TD><TD>                            log.error(&#34;Unable to apply diff to key:&#34; + entry.getKey(), x);</TD></TR><TR CLASS="z"><TD CLASS="l">665</TD><TD>                        } finally {</TD></TR><TR CLASS="z"><TD CLASS="l">666</TD><TD>                            diff.unlock();</TD></TR><TR CLASS="z"><TD CLASS="l">667</TD><TD>                        }</TD></TR><TR><TD CLASS="l">668</TD><TD>                    } else {</TD></TR><TR CLASS="z"><TD CLASS="l">669</TD><TD>                        if ( mapmsg.getValue()!=null ) entry.setValue((V) mapmsg.getValue());</TD></TR><TR CLASS="z"><TD CLASS="l">670</TD><TD>                        ((ReplicatedMapEntry)entry.getValue()).setOwner(getMapOwner());</TD></TR><TR><TD CLASS="l">671</TD><TD>                    } //end if</TD></TR><TR CLASS="z"><TD CLASS="l">672</TD><TD>                } else if  (mapmsg.getValue() instanceof ReplicatedMapEntry) {</TD></TR><TR CLASS="z"><TD CLASS="l">673</TD><TD>                    ReplicatedMapEntry re = (ReplicatedMapEntry)mapmsg.getValue();</TD></TR><TR CLASS="z"><TD CLASS="l">674</TD><TD>                    re.setOwner(getMapOwner());</TD></TR><TR CLASS="z"><TD CLASS="l">675</TD><TD>                    entry.setValue((V) re);</TD></TR><TR CLASS="z"><TD CLASS="l">676</TD><TD>                } else {</TD></TR><TR CLASS="z"><TD CLASS="l">677</TD><TD>                    if ( mapmsg.getValue()!=null ) entry.setValue((V) mapmsg.getValue());</TD></TR><TR><TD CLASS="l">678</TD><TD>                } //end if</TD></TR><TR><TD CLASS="l">679</TD><TD>            } //end if</TD></TR><TR CLASS="z"><TD CLASS="l">680</TD><TD>            innerMap.put(entry.getKey(), entry);</TD></TR><TR><TD CLASS="l">681</TD><TD>        } //end if</TD></TR><TR><TD CLASS="l">682</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">683</TD><TD>        if (mapmsg.getMsgType() == MapMessage.MSG_ACCESS) {</TD></TR><TR CLASS="z"><TD CLASS="l">684</TD><TD>            MapEntry&lt;K, V&gt; entry = innerMap.get(mapmsg.getKey());</TD></TR><TR CLASS="z"><TD CLASS="l">685</TD><TD>            if (entry != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">686</TD><TD>                entry.setBackupNodes(mapmsg.getBackupNodes());</TD></TR><TR CLASS="z"><TD CLASS="l">687</TD><TD>                entry.setPrimary(mapmsg.getPrimary());</TD></TR><TR><TD CLASS="l">688</TD><TD>            }</TD></TR><TR><TD CLASS="l"><A NAME="2">689</A></TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">690</TD><TD>    }</TD></TR><TR><TD CLASS="l">691</TD><TD> </TD></TR><TR><TD CLASS="l">692</TD><TD>    public boolean accept(Serializable msg, Member sender) {</TD></TR><TR CLASS="z"><TD CLASS="l">693</TD><TD>        boolean result = false;</TD></TR><TR CLASS="z"><TD CLASS="l">694</TD><TD>        if (msg instanceof MapMessage) {</TD></TR><TR CLASS="z"><TD CLASS="l">695</TD><TD>            if ( log.isTraceEnabled() ) log.trace(&#34;Map[&#34;+mapname+&#34;] accepting....&#34;+msg);</TD></TR><TR CLASS="z"><TD CLASS="l">696</TD><TD>            result = Arrays.equals(mapContextName, ( (MapMessage) msg).getMapId());</TD></TR><TR CLASS="z"><TD CLASS="l">697</TD><TD>            if ( log.isTraceEnabled() ) log.trace(&#34;Msg[&#34;+mapname+&#34;] accepted[&#34;+result+&#34;]....&#34;+msg);</TD></TR><TR><TD CLASS="l">698</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="28">699</A></TD><TD>        return result;</TD></TR><TR><TD CLASS="l">700</TD><TD>    }</TD></TR><TR><TD CLASS="l">701</TD><TD> </TD></TR><TR><TD CLASS="l">702</TD><TD>    public void mapMemberAdded(Member member) {</TD></TR><TR CLASS="z"><TD CLASS="l">703</TD><TD>        if ( member.equals(getChannel().getLocalMember(false)) ) return;</TD></TR><TR CLASS="z"><TD CLASS="l">704</TD><TD>        boolean memberAdded = false;</TD></TR><TR><TD CLASS="l">705</TD><TD>        //select a backup node if we don't have one</TD></TR><TR CLASS="z"><TD CLASS="l">706</TD><TD>        synchronized (mapMembers) {</TD></TR><TR CLASS="z"><TD CLASS="l">707</TD><TD>            if (!mapMembers.containsKey(member) ) {</TD></TR><TR CLASS="z"><TD CLASS="l">708</TD><TD>                mapMembers.put(member, new Long(System.currentTimeMillis()));</TD></TR><TR CLASS="z"><TD CLASS="l">709</TD><TD>                memberAdded = true;</TD></TR><TR><TD CLASS="l">710</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">711</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">712</TD><TD>        if ( memberAdded ) {</TD></TR><TR CLASS="z"><TD CLASS="l">713</TD><TD>            synchronized (stateMutex) {</TD></TR><TR CLASS="z"><TD CLASS="l">714</TD><TD>                Iterator&lt;Map.Entry&lt;K,MapEntry&lt;K,V&gt;&gt;&gt; i = innerMap.entrySet().iterator();</TD></TR><TR CLASS="z"><TD CLASS="l">715</TD><TD>                while (i.hasNext()) {</TD></TR><TR CLASS="z"><TD CLASS="l">716</TD><TD>                    Map.Entry&lt;K,MapEntry&lt;K,V&gt;&gt; e = i.next();</TD></TR><TR CLASS="z"><TD CLASS="l">717</TD><TD>                    MapEntry&lt;K,V&gt; entry = innerMap.get(e.getKey());</TD></TR><TR CLASS="z"><TD CLASS="l">718</TD><TD>                    if ( entry == null ) continue;</TD></TR><TR CLASS="z"><TD CLASS="l">719</TD><TD>                    if (entry.isPrimary() &amp;&amp; (entry.getBackupNodes() == null || entry.getBackupNodes().length == 0)) {</TD></TR><TR><TD CLASS="l">720</TD><TD>                        try {</TD></TR><TR CLASS="z"><TD CLASS="l">721</TD><TD>                            Member[] backup = publishEntryInfo(entry.getKey(), entry.getValue());</TD></TR><TR CLASS="z"><TD CLASS="l">722</TD><TD>                            entry.setBackupNodes(backup);</TD></TR><TR CLASS="z"><TD CLASS="l">723</TD><TD>                            entry.setPrimary(channel.getLocalMember(false));</TD></TR><TR CLASS="z"><TD CLASS="l">724</TD><TD>                        } catch (ChannelException x) {</TD></TR><TR CLASS="z"><TD CLASS="l">725</TD><TD>                            log.error(&#34;Unable to select backup node.&#34;, x);</TD></TR><TR CLASS="z"><TD CLASS="l">726</TD><TD>                        } //catch</TD></TR><TR><TD CLASS="l">727</TD><TD>                    } //end if</TD></TR><TR CLASS="z"><TD CLASS="l">728</TD><TD>                } //while</TD></TR><TR CLASS="z"><TD CLASS="l">729</TD><TD>            } //synchronized</TD></TR><TR><TD CLASS="l"><A NAME="21">730</A></TD><TD>        }//end if</TD></TR><TR CLASS="z"><TD CLASS="l">731</TD><TD>    }</TD></TR><TR><TD CLASS="l">732</TD><TD> </TD></TR><TR><TD CLASS="l">733</TD><TD>    public boolean inSet(Member m, Member[] set) {</TD></TR><TR CLASS="z"><TD CLASS="l">734</TD><TD>        if ( set == null ) return false;</TD></TR><TR CLASS="z"><TD CLASS="l">735</TD><TD>        boolean result = false;</TD></TR><TR CLASS="z"><TD CLASS="l">736</TD><TD>        for (int i=0; i&lt;set.length &amp;&amp; (!result); i++ )</TD></TR><TR CLASS="z"><TD CLASS="l">737</TD><TD>            if ( m.equals(set[i]) ) result = true;</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="d">738</A></TD><TD>        return result;</TD></TR><TR><TD CLASS="l">739</TD><TD>    }</TD></TR><TR><TD CLASS="l">740</TD><TD> </TD></TR><TR><TD CLASS="l">741</TD><TD>    public Member[] excludeFromSet(Member[] mbrs, Member[] set) {</TD></TR><TR CLASS="z"><TD CLASS="l">742</TD><TD>        ArrayList&lt;Member&gt; result = new ArrayList&lt;Member&gt;();</TD></TR><TR CLASS="z"><TD CLASS="l">743</TD><TD>        for (int i=0; i&lt;set.length; i++ ) {</TD></TR><TR CLASS="z"><TD CLASS="l">744</TD><TD>            boolean include = true;</TD></TR><TR CLASS="z"><TD CLASS="l">745</TD><TD>            for (int j=0; j&lt;mbrs.length &amp;&amp; include; j++ )</TD></TR><TR CLASS="z"><TD CLASS="l">746</TD><TD>                if ( mbrs[j].equals(set[i]) ) include = false;</TD></TR><TR CLASS="z"><TD CLASS="l">747</TD><TD>            if ( include ) result.add(set[i]);</TD></TR><TR><TD CLASS="l">748</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">749</TD><TD>        return result.toArray(new Member[result.size()]);</TD></TR><TR><TD CLASS="l"><A NAME="29">750</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">751</TD><TD> </TD></TR><TR><TD CLASS="l">752</TD><TD>    public void memberAdded(Member member) {</TD></TR><TR><TD CLASS="l"><A NAME="2b">753</A></TD><TD>        //do nothing</TD></TR><TR CLASS="z"><TD CLASS="l">754</TD><TD>    }</TD></TR><TR><TD CLASS="l">755</TD><TD> </TD></TR><TR><TD CLASS="l">756</TD><TD>    public void memberDisappeared(Member member) {</TD></TR><TR CLASS="z"><TD CLASS="l">757</TD><TD>        boolean removed = false;</TD></TR><TR CLASS="z"><TD CLASS="l">758</TD><TD>        synchronized (mapMembers) {</TD></TR><TR CLASS="z"><TD CLASS="l">759</TD><TD>            removed = (mapMembers.remove(member) != null );</TD></TR><TR CLASS="z"><TD CLASS="l">760</TD><TD>            if (!removed) {</TD></TR><TR CLASS="z"><TD CLASS="l">761</TD><TD>                if (log.isDebugEnabled()) log.debug(&#34;Member[&#34;+member+&#34;] disappeared, but was not present in the map.&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">762</TD><TD>                return; //the member was not part of our map.</TD></TR><TR><TD CLASS="l">763</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">764</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">765</TD><TD>        if (log.isInfoEnabled())</TD></TR><TR CLASS="z"><TD CLASS="l">766</TD><TD>            log.info(&#34;Member[&#34;+member+&#34;] disappeared. Related map entries will be relocated to the new node.&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">767</TD><TD>        long start = System.currentTimeMillis();</TD></TR><TR CLASS="z"><TD CLASS="l">768</TD><TD>        Iterator&lt;Map.Entry&lt;K,MapEntry&lt;K,V&gt;&gt;&gt; i = innerMap.entrySet().iterator();</TD></TR><TR CLASS="z"><TD CLASS="l">769</TD><TD>        while (i.hasNext()) {</TD></TR><TR CLASS="z"><TD CLASS="l">770</TD><TD>            Map.Entry&lt;K,MapEntry&lt;K,V&gt;&gt; e = i.next();</TD></TR><TR CLASS="z"><TD CLASS="l">771</TD><TD>            MapEntry&lt;K,V&gt; entry = innerMap.get(e.getKey());</TD></TR><TR CLASS="z"><TD CLASS="l">772</TD><TD>            if (entry==null) continue;</TD></TR><TR CLASS="z"><TD CLASS="l">773</TD><TD>            if (entry.isPrimary() &amp;&amp; inSet(member,entry.getBackupNodes())) {</TD></TR><TR CLASS="z"><TD CLASS="l">774</TD><TD>                if (log.isDebugEnabled()) log.debug(&#34;[1] Primary choosing a new backup&#34;);</TD></TR><TR><TD CLASS="l">775</TD><TD>                try {</TD></TR><TR CLASS="z"><TD CLASS="l">776</TD><TD>                    Member[] backup = publishEntryInfo(entry.getKey(), entry.getValue());</TD></TR><TR CLASS="z"><TD CLASS="l">777</TD><TD>                    entry.setBackupNodes(backup);</TD></TR><TR CLASS="z"><TD CLASS="l">778</TD><TD>                    entry.setPrimary(channel.getLocalMember(false));</TD></TR><TR CLASS="z"><TD CLASS="l">779</TD><TD>                } catch (ChannelException x) {</TD></TR><TR CLASS="z"><TD CLASS="l">780</TD><TD>                    log.error(&#34;Unable to relocate[&#34; + entry.getKey() + &#34;] to a new backup node&#34;, x);</TD></TR><TR CLASS="z"><TD CLASS="l">781</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">782</TD><TD>            } else if (member.equals(entry.getPrimary())) {</TD></TR><TR CLASS="z"><TD CLASS="l">783</TD><TD>                if (log.isDebugEnabled()) log.debug(&#34;[2] Primary disappeared&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">784</TD><TD>                entry.setPrimary(null);</TD></TR><TR><TD CLASS="l">785</TD><TD>            } //end if</TD></TR><TR><TD CLASS="l">786</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">787</TD><TD>            if ( entry.isProxy() &amp;&amp;</TD></TR><TR CLASS="z"><TD CLASS="l">788</TD><TD>                 entry.getPrimary() == null &amp;&amp;</TD></TR><TR CLASS="z"><TD CLASS="l">789</TD><TD>                 entry.getBackupNodes()!=null &amp;&amp;</TD></TR><TR CLASS="z"><TD CLASS="l">790</TD><TD>                 entry.getBackupNodes().length == 1 &amp;&amp;</TD></TR><TR CLASS="z"><TD CLASS="l">791</TD><TD>                 entry.getBackupNodes()[0].equals(member) ) {</TD></TR><TR><TD CLASS="l">792</TD><TD>                //remove proxies that have no backup nor primaries</TD></TR><TR CLASS="z"><TD CLASS="l">793</TD><TD>                if (log.isDebugEnabled()) log.debug(&#34;[3] Removing orphaned proxy&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">794</TD><TD>                i.remove();</TD></TR><TR CLASS="z"><TD CLASS="l">795</TD><TD>            } else if ( entry.getPrimary() == null &amp;&amp;</TD></TR><TR CLASS="z"><TD CLASS="l">796</TD><TD>                        entry.isBackup() &amp;&amp;</TD></TR><TR CLASS="z"><TD CLASS="l">797</TD><TD>                        entry.getBackupNodes()!=null &amp;&amp;</TD></TR><TR CLASS="z"><TD CLASS="l">798</TD><TD>                        entry.getBackupNodes().length == 1 &amp;&amp;</TD></TR><TR CLASS="z"><TD CLASS="l">799</TD><TD>                        entry.getBackupNodes()[0].equals(channel.getLocalMember(false)) ) {</TD></TR><TR><TD CLASS="l">800</TD><TD>                try {</TD></TR><TR CLASS="z"><TD CLASS="l">801</TD><TD>                    if (log.isDebugEnabled()) log.debug(&#34;[4] Backup becoming primary&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">802</TD><TD>                    entry.setPrimary(channel.getLocalMember(false));</TD></TR><TR CLASS="z"><TD CLASS="l">803</TD><TD>                    entry.setBackup(false);</TD></TR><TR CLASS="z"><TD CLASS="l">804</TD><TD>                    entry.setProxy(false);</TD></TR><TR CLASS="z"><TD CLASS="l">805</TD><TD>                    Member[] backup = publishEntryInfo(entry.getKey(), entry.getValue());</TD></TR><TR CLASS="z"><TD CLASS="l">806</TD><TD>                    entry.setBackupNodes(backup);</TD></TR><TR CLASS="z"><TD CLASS="l">807</TD><TD>                    if ( mapOwner!=null ) mapOwner.objectMadePrimay(entry.getKey(),entry.getValue());</TD></TR><TR><TD CLASS="l">808</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">809</TD><TD>                } catch (ChannelException x) {</TD></TR><TR CLASS="z"><TD CLASS="l">810</TD><TD>                    log.error(&#34;Unable to relocate[&#34; + entry.getKey() + &#34;] to a new backup node&#34;, x);</TD></TR><TR CLASS="z"><TD CLASS="l">811</TD><TD>                }</TD></TR><TR><TD CLASS="l">812</TD><TD>            }</TD></TR><TR><TD CLASS="l">813</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">814</TD><TD>        } //while</TD></TR><TR CLASS="z"><TD CLASS="l">815</TD><TD>        long complete = System.currentTimeMillis() - start;</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="1a">816</A></TD><TD>        if (log.isInfoEnabled()) log.info(&#34;Relocation of map entries was complete in &#34; + complete + &#34; ms.&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">817</TD><TD>    }</TD></TR><TR><TD CLASS="l">818</TD><TD> </TD></TR><TR><TD CLASS="l">819</TD><TD>    public int getNextBackupIndex() {</TD></TR><TR CLASS="z"><TD CLASS="l">820</TD><TD>        int size = mapMembers.size();</TD></TR><TR CLASS="z"><TD CLASS="l">821</TD><TD>        if (mapMembers.size() == 0)return -1;</TD></TR><TR CLASS="z"><TD CLASS="l">822</TD><TD>        int node = currentNode++;</TD></TR><TR CLASS="z"><TD CLASS="l">823</TD><TD>        if (node &gt;= size) {</TD></TR><TR CLASS="z"><TD CLASS="l">824</TD><TD>            node = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">825</TD><TD>            currentNode = 0;</TD></TR><TR><TD CLASS="l"><A NAME="1b">826</A></TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">827</TD><TD>        return node;</TD></TR><TR><TD CLASS="l">828</TD><TD>    }</TD></TR><TR><TD CLASS="l">829</TD><TD>    public Member getNextBackupNode() {</TD></TR><TR CLASS="z"><TD CLASS="l">830</TD><TD>        Member[] members = getMapMembers();</TD></TR><TR CLASS="z"><TD CLASS="l">831</TD><TD>        int node = getNextBackupIndex();</TD></TR><TR CLASS="z"><TD CLASS="l">832</TD><TD>        if ( members.length == 0 || node==-1) return null;</TD></TR><TR CLASS="z"><TD CLASS="l">833</TD><TD>        if ( node &gt;= members.length ) node = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">834</TD><TD>        return members[node];</TD></TR><TR><TD CLASS="l">835</TD><TD>    }</TD></TR><TR><TD CLASS="l">836</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="20">837</A></TD><TD>    protected abstract Member[] publishEntryInfo(Object key, Object value) throws ChannelException;</TD></TR><TR><TD CLASS="l">838</TD><TD> </TD></TR><TR><TD CLASS="l">839</TD><TD>    public void heartbeat() {</TD></TR><TR><TD CLASS="l">840</TD><TD>        try {</TD></TR><TR CLASS="z"><TD CLASS="l">841</TD><TD>            ping(accessTimeout);</TD></TR><TR CLASS="z"><TD CLASS="l">842</TD><TD>        }catch ( Exception x ) {</TD></TR><TR CLASS="z"><TD CLASS="l">843</TD><TD>            log.error(&#34;Unable to send AbstractReplicatedMap.ping message&#34;,x);</TD></TR><TR CLASS="z"><TD CLASS="l">844</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">845</TD><TD>    }</TD></TR><TR><TD CLASS="l">846</TD><TD> </TD></TR><TR><TD CLASS="l">847</TD><TD>//------------------------------------------------------------------------------</TD></TR><TR><TD CLASS="l">848</TD><TD>//              METHODS TO OVERRIDE</TD></TR><TR><TD CLASS="l">849</TD><TD>//------------------------------------------------------------------------------</TD></TR><TR><TD CLASS="l">850</TD><TD> </TD></TR><TR><TD CLASS="l">851</TD><TD>    /**</TD></TR><TR><TD CLASS="l">852</TD><TD>     * Removes an object from this map, it will also remove it from</TD></TR><TR><TD CLASS="l">853</TD><TD>     *</TD></TR><TR><TD CLASS="l"><A NAME="32">854</A></TD><TD>     * @param key Object</TD></TR><TR><TD CLASS="l">855</TD><TD>     * @return Object</TD></TR><TR><TD CLASS="l">856</TD><TD>     */</TD></TR><TR><TD CLASS="l"><A NAME="33">857</A></TD><TD>    public V remove(Object key) {</TD></TR><TR CLASS="z"><TD CLASS="l">858</TD><TD>        return remove(key,true);</TD></TR><TR><TD CLASS="l">859</TD><TD>    }</TD></TR><TR><TD CLASS="l">860</TD><TD>    public V remove(Object key, boolean notify) {</TD></TR><TR CLASS="z"><TD CLASS="l">861</TD><TD>        MapEntry&lt;K,V&gt; entry = innerMap.remove(key);</TD></TR><TR><TD CLASS="l">862</TD><TD> </TD></TR><TR><TD CLASS="l">863</TD><TD>        try {</TD></TR><TR CLASS="z"><TD CLASS="l">864</TD><TD>            if (getMapMembers().length &gt; 0 &amp;&amp; notify) {</TD></TR><TR CLASS="z"><TD CLASS="l">865</TD><TD>                MapMessage msg = new MapMessage(getMapContextName(), MapMessage.MSG_REMOVE, false, (Serializable) key, null, null, null,null);</TD></TR><TR CLASS="z"><TD CLASS="l">866</TD><TD>                getChannel().send(getMapMembers(), msg, getChannelSendOptions());</TD></TR><TR><TD CLASS="l">867</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">868</TD><TD>        } catch ( ChannelException x ) {</TD></TR><TR CLASS="z"><TD CLASS="l">869</TD><TD>            log.error(&#34;Unable to replicate out data for a LazyReplicatedMap.remove operation&#34;,x);</TD></TR><TR CLASS="z"><TD CLASS="l">870</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="14">871</A></TD><TD>        return entry!=null?entry.getValue():null;</TD></TR><TR><TD CLASS="l">872</TD><TD>    }</TD></TR><TR><TD CLASS="l">873</TD><TD> </TD></TR><TR><TD CLASS="l">874</TD><TD>    public MapEntry&lt;K,V&gt; getInternal(Object key) {</TD></TR><TR CLASS="z"><TD CLASS="l">875</TD><TD>        return innerMap.get(key);</TD></TR><TR><TD CLASS="l"><A NAME="f">876</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">877</TD><TD> </TD></TR><TR><TD CLASS="l">878</TD><TD>    @SuppressWarnings(&#34;unchecked&#34;)</TD></TR><TR><TD CLASS="l">879</TD><TD>    public V get(Object key) {</TD></TR><TR CLASS="z"><TD CLASS="l">880</TD><TD>        MapEntry&lt;K,V&gt; entry = innerMap.get(key);</TD></TR><TR CLASS="z"><TD CLASS="l">881</TD><TD>        if (log.isTraceEnabled()) log.trace(&#34;Requesting id:&#34;+key+&#34; entry:&#34;+entry);</TD></TR><TR CLASS="z"><TD CLASS="l">882</TD><TD>        if ( entry == null ) return null;</TD></TR><TR CLASS="z"><TD CLASS="l">883</TD><TD>        if ( !entry.isPrimary() ) {</TD></TR><TR><TD CLASS="l">884</TD><TD>            //if the message is not primary, we need to retrieve the latest value</TD></TR><TR><TD CLASS="l">885</TD><TD>            try {</TD></TR><TR CLASS="z"><TD CLASS="l">886</TD><TD>                Member[] backup = null;</TD></TR><TR CLASS="z"><TD CLASS="l">887</TD><TD>                MapMessage msg = null;</TD></TR><TR CLASS="z"><TD CLASS="l">888</TD><TD>                if ( !entry.isBackup() ) {</TD></TR><TR><TD CLASS="l">889</TD><TD>                    //make sure we don't retrieve from ourselves</TD></TR><TR CLASS="z"><TD CLASS="l">890</TD><TD>                    msg = new MapMessage(getMapContextName(), MapMessage.MSG_RETRIEVE_BACKUP, false,</TD></TR><TR><TD CLASS="l">891</TD><TD>                                         (Serializable) key, null, null, null,null);</TD></TR><TR CLASS="z"><TD CLASS="l">892</TD><TD>                    Response[] resp = getRpcChannel().send(entry.getBackupNodes(),msg, RpcChannel.FIRST_REPLY, Channel.SEND_OPTIONS_DEFAULT, getRpcTimeout());</TD></TR><TR CLASS="z"><TD CLASS="l">893</TD><TD>                    if (resp == null || resp.length == 0) {</TD></TR><TR><TD CLASS="l">894</TD><TD>                        //no responses</TD></TR><TR CLASS="z"><TD CLASS="l">895</TD><TD>                        log.warn(&#34;Unable to retrieve remote object for key:&#34; + key);</TD></TR><TR CLASS="z"><TD CLASS="l">896</TD><TD>                        return null;</TD></TR><TR><TD CLASS="l">897</TD><TD>                    }</TD></TR><TR CLASS="z"><TD CLASS="l">898</TD><TD>                    msg = (MapMessage) resp[0].getMessage();</TD></TR><TR CLASS="z"><TD CLASS="l">899</TD><TD>                    msg.deserialize(getExternalLoaders());</TD></TR><TR CLASS="z"><TD CLASS="l">900</TD><TD>                    backup = entry.getBackupNodes();</TD></TR><TR CLASS="z"><TD CLASS="l">901</TD><TD>                    if ( entry.getValue() instanceof ReplicatedMapEntry ) {</TD></TR><TR CLASS="z"><TD CLASS="l">902</TD><TD>                        ReplicatedMapEntry val = (ReplicatedMapEntry)entry.getValue();</TD></TR><TR CLASS="z"><TD CLASS="l">903</TD><TD>                        val.setOwner(getMapOwner());</TD></TR><TR><TD CLASS="l">904</TD><TD>                    }</TD></TR><TR CLASS="z"><TD CLASS="l">905</TD><TD>                    if ( msg.getValue()!=null ) entry.setValue((V) msg.getValue());</TD></TR><TR><TD CLASS="l">906</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">907</TD><TD>                if (entry.isBackup()) {</TD></TR><TR><TD CLASS="l">908</TD><TD>                    //select a new backup node</TD></TR><TR CLASS="z"><TD CLASS="l">909</TD><TD>                    backup = publishEntryInfo(key, entry.getValue());</TD></TR><TR CLASS="z"><TD CLASS="l">910</TD><TD>                } else if ( entry.isProxy() ) {</TD></TR><TR><TD CLASS="l">911</TD><TD>                    //invalidate the previous primary</TD></TR><TR CLASS="z"><TD CLASS="l">912</TD><TD>                    msg = new MapMessage(getMapContextName(),MapMessage.MSG_PROXY,false,(Serializable)key,null,null,channel.getLocalMember(false),backup);</TD></TR><TR CLASS="z"><TD CLASS="l">913</TD><TD>                    Member[] dest = getMapMembersExcl(backup);</TD></TR><TR CLASS="z"><TD CLASS="l">914</TD><TD>                    if ( dest!=null &amp;&amp; dest.length &gt;0) {</TD></TR><TR CLASS="z"><TD CLASS="l">915</TD><TD>                        getChannel().send(dest, msg, getChannelSendOptions());</TD></TR><TR><TD CLASS="l">916</TD><TD>                    }</TD></TR><TR CLASS="z"><TD CLASS="l">917</TD><TD>                    if ( entry.getValue() != null &amp;&amp; entry.getValue() instanceof ReplicatedMapEntry ) {</TD></TR><TR CLASS="z"><TD CLASS="l">918</TD><TD>                        ReplicatedMapEntry val = (ReplicatedMapEntry)entry.getValue();</TD></TR><TR CLASS="z"><TD CLASS="l">919</TD><TD>                        val.setOwner(getMapOwner());</TD></TR><TR><TD CLASS="l">920</TD><TD>                    }</TD></TR><TR><TD CLASS="l">921</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">922</TD><TD>                entry.setPrimary(channel.getLocalMember(false));</TD></TR><TR CLASS="z"><TD CLASS="l">923</TD><TD>                entry.setBackupNodes(backup);</TD></TR><TR CLASS="z"><TD CLASS="l">924</TD><TD>                entry.setBackup(false);</TD></TR><TR CLASS="z"><TD CLASS="l">925</TD><TD>                entry.setProxy(false);</TD></TR><TR CLASS="z"><TD CLASS="l">926</TD><TD>                if ( getMapOwner()!=null ) getMapOwner().objectMadePrimay(key, entry.getValue());</TD></TR><TR><TD CLASS="l">927</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">928</TD><TD>            } catch (Exception x) {</TD></TR><TR CLASS="z"><TD CLASS="l">929</TD><TD>                log.error(&#34;Unable to replicate out data for a LazyReplicatedMap.get operation&#34;, x);</TD></TR><TR CLASS="z"><TD CLASS="l">930</TD><TD>                return null;</TD></TR><TR CLASS="z"><TD CLASS="l">931</TD><TD>            }</TD></TR><TR><TD CLASS="l">932</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">933</TD><TD>        if (log.isTraceEnabled()) log.trace(&#34;Requesting id:&#34;+key+&#34; result:&#34;+entry.getValue());</TD></TR><TR CLASS="z"><TD CLASS="l">934</TD><TD>        return entry.getValue();</TD></TR><TR><TD CLASS="l">935</TD><TD>    }</TD></TR><TR><TD CLASS="l"><A NAME="2e">936</A></TD><TD> </TD></TR><TR><TD CLASS="l">937</TD><TD> </TD></TR><TR><TD CLASS="l">938</TD><TD>    protected void printMap(String header) {</TD></TR><TR><TD CLASS="l">939</TD><TD>        try {</TD></TR><TR CLASS="z"><TD CLASS="l">940</TD><TD>            System.out.println(&#34;\nDEBUG MAP:&#34;+header);</TD></TR><TR><TD CLASS="l">941</TD><TD>            try {</TD></TR><TR CLASS="z"><TD CLASS="l">942</TD><TD>                System.out.println(&#34;Map[&#34; +</TD></TR><TR><TD CLASS="l">943</TD><TD>                        new String(mapContextName, &#34;ISO-8859-1&#34;) +</TD></TR><TR CLASS="z"><TD CLASS="l">944</TD><TD>                        &#34;, Map Size:&#34; + innerMap.size());</TD></TR><TR CLASS="z"><TD CLASS="l">945</TD><TD>            } catch (UnsupportedEncodingException uee) {</TD></TR><TR><TD CLASS="l">946</TD><TD>                // Impossible. All JVMs are required to support ISO-8859-1</TD></TR><TR CLASS="z"><TD CLASS="l">947</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">948</TD><TD>            Member[] mbrs = getMapMembers();</TD></TR><TR CLASS="z"><TD CLASS="l">949</TD><TD>            for ( int i=0; i&lt;mbrs.length;i++ ) {</TD></TR><TR CLASS="z"><TD CLASS="l">950</TD><TD>                System.out.println(&#34;Mbr[&#34;+(i+1)+&#34;=&#34;+mbrs[i].getName());</TD></TR><TR><TD CLASS="l">951</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">952</TD><TD>            Iterator&lt;Map.Entry&lt;K,MapEntry&lt;K,V&gt;&gt;&gt; i = innerMap.entrySet().iterator();</TD></TR><TR CLASS="z"><TD CLASS="l">953</TD><TD>            int cnt = 0;</TD></TR><TR><TD CLASS="l">954</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">955</TD><TD>            while (i.hasNext()) {</TD></TR><TR CLASS="z"><TD CLASS="l">956</TD><TD>                Map.Entry&lt;?,?&gt; e = i.next();</TD></TR><TR CLASS="z"><TD CLASS="l">957</TD><TD>                System.out.println( (++cnt) + &#34;. &#34; + innerMap.get(e.getKey()));</TD></TR><TR CLASS="z"><TD CLASS="l">958</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">959</TD><TD>            System.out.println(&#34;EndMap]\n\n&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">960</TD><TD>        }catch ( Exception ignore) {</TD></TR><TR CLASS="z"><TD CLASS="l">961</TD><TD>            ignore.printStackTrace();</TD></TR><TR CLASS="z"><TD CLASS="l">962</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">963</TD><TD>    }</TD></TR><TR><TD CLASS="l">964</TD><TD> </TD></TR><TR><TD CLASS="l">965</TD><TD>    /**</TD></TR><TR><TD CLASS="l">966</TD><TD>     * Returns true if the key has an entry in the map.</TD></TR><TR><TD CLASS="l">967</TD><TD>     * The entry can be a proxy or a backup entry, invoking &lt;code&gt;get(key)&lt;/code&gt;</TD></TR><TR><TD CLASS="l">968</TD><TD>     * will make this entry primary for the group</TD></TR><TR><TD CLASS="l"><A NAME="8">969</A></TD><TD>     * @param key Object</TD></TR><TR><TD CLASS="l">970</TD><TD>     * @return boolean</TD></TR><TR><TD CLASS="l">971</TD><TD>     */</TD></TR><TR><TD CLASS="l">972</TD><TD>    public boolean containsKey(Object key) {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="2f">973</A></TD><TD>        return innerMap.containsKey(key);</TD></TR><TR><TD CLASS="l">974</TD><TD>    }</TD></TR><TR><TD CLASS="l">975</TD><TD> </TD></TR><TR><TD CLASS="l">976</TD><TD>    public V put(K key, V value) {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="30">977</A></TD><TD>        return put(key, value, true);</TD></TR><TR><TD CLASS="l">978</TD><TD>    }</TD></TR><TR><TD CLASS="l">979</TD><TD> </TD></TR><TR><TD CLASS="l">980</TD><TD>    public V put(K key, V value, boolean notify) {</TD></TR><TR CLASS="z"><TD CLASS="l">981</TD><TD>        MapEntry&lt;K,V&gt; entry = new MapEntry&lt;K,V&gt;(key,value);</TD></TR><TR CLASS="z"><TD CLASS="l">982</TD><TD>        entry.setBackup(false);</TD></TR><TR CLASS="z"><TD CLASS="l">983</TD><TD>        entry.setProxy(false);</TD></TR><TR CLASS="z"><TD CLASS="l">984</TD><TD>        entry.setPrimary(channel.getLocalMember(false));</TD></TR><TR><TD CLASS="l">985</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">986</TD><TD>        V old = null;</TD></TR><TR><TD CLASS="l">987</TD><TD> </TD></TR><TR><TD CLASS="l">988</TD><TD>        //make sure that any old values get removed</TD></TR><TR CLASS="z"><TD CLASS="l">989</TD><TD>        if ( containsKey(key) ) old = remove(key);</TD></TR><TR><TD CLASS="l">990</TD><TD>        try {</TD></TR><TR CLASS="z"><TD CLASS="l">991</TD><TD>            if ( notify ) {</TD></TR><TR CLASS="z"><TD CLASS="l">992</TD><TD>                Member[] backup = publishEntryInfo(key, value);</TD></TR><TR CLASS="z"><TD CLASS="l">993</TD><TD>                entry.setBackupNodes(backup);</TD></TR><TR><TD CLASS="l">994</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">995</TD><TD>        } catch (ChannelException x) {</TD></TR><TR CLASS="z"><TD CLASS="l">996</TD><TD>            log.error(&#34;Unable to replicate out data for a LazyReplicatedMap.put operation&#34;, x);</TD></TR><TR CLASS="z"><TD CLASS="l">997</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">998</TD><TD>        innerMap.put(key,entry);</TD></TR><TR CLASS="z"><TD CLASS="l">999</TD><TD>        return old;</TD></TR><TR><TD CLASS="l">1000</TD><TD>    }</TD></TR><TR><TD CLASS="l">1001</TD><TD> </TD></TR><TR><TD CLASS="l">1002</TD><TD> </TD></TR><TR><TD CLASS="l">1003</TD><TD>    /**</TD></TR><TR><TD CLASS="l"><A NAME="31">1004</A></TD><TD>     * Copies all values from one map to this instance</TD></TR><TR><TD CLASS="l">1005</TD><TD>     * @param m Map</TD></TR><TR><TD CLASS="l">1006</TD><TD>     */</TD></TR><TR><TD CLASS="l">1007</TD><TD>    public void putAll(Map&lt;? extends K, ? extends V&gt; m) {</TD></TR><TR CLASS="z"><TD CLASS="l">1008</TD><TD>        Iterator&lt;?&gt; i = m.entrySet().iterator();</TD></TR><TR CLASS="z"><TD CLASS="l">1009</TD><TD>        while ( i.hasNext() ) {</TD></TR><TR><TD CLASS="l">1010</TD><TD>            @SuppressWarnings(&#34;unchecked&#34;)</TD></TR><TR CLASS="z"><TD CLASS="l">1011</TD><TD>            Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;) i.next();</TD></TR><TR CLASS="z"><TD CLASS="l">1012</TD><TD>            put(entry.getKey(),entry.getValue());</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="5">1013</A></TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1014</TD><TD>    }</TD></TR><TR><TD CLASS="l">1015</TD><TD> </TD></TR><TR><TD CLASS="l">1016</TD><TD>    public void clear() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="6">1017</A></TD><TD>        clear(true);</TD></TR><TR CLASS="z"><TD CLASS="l">1018</TD><TD>    }</TD></TR><TR><TD CLASS="l">1019</TD><TD> </TD></TR><TR><TD CLASS="l">1020</TD><TD>    public void clear(boolean notify) {</TD></TR><TR CLASS="z"><TD CLASS="l">1021</TD><TD>        if ( notify ) {</TD></TR><TR><TD CLASS="l">1022</TD><TD>            //only delete active keys</TD></TR><TR CLASS="z"><TD CLASS="l">1023</TD><TD>            Iterator&lt;K&gt; keys = keySet().iterator();</TD></TR><TR CLASS="z"><TD CLASS="l">1024</TD><TD>            while (keys.hasNext())</TD></TR><TR CLASS="z"><TD CLASS="l">1025</TD><TD>                remove(keys.next());</TD></TR><TR CLASS="z"><TD CLASS="l">1026</TD><TD>        } else {</TD></TR><TR CLASS="z"><TD CLASS="l">1027</TD><TD>            innerMap.clear();</TD></TR><TR><TD CLASS="l"><A NAME="9">1028</A></TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1029</TD><TD>    }</TD></TR><TR><TD CLASS="l">1030</TD><TD> </TD></TR><TR><TD CLASS="l">1031</TD><TD>    public boolean containsValue(Object value) {</TD></TR><TR CLASS="z"><TD CLASS="l">1032</TD><TD>        if (value == null) {</TD></TR><TR CLASS="z"><TD CLASS="l">1033</TD><TD>            throw new NullPointerException();</TD></TR><TR><TD CLASS="l">1034</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1035</TD><TD>        Iterator&lt;Map.Entry&lt;K,MapEntry&lt;K,V&gt;&gt;&gt; i = innerMap.entrySet().iterator();</TD></TR><TR CLASS="z"><TD CLASS="l">1036</TD><TD>        while (i.hasNext()) {</TD></TR><TR CLASS="z"><TD CLASS="l">1037</TD><TD>            Map.Entry&lt;K,MapEntry&lt;K,V&gt;&gt; e = i.next();</TD></TR><TR CLASS="z"><TD CLASS="l">1038</TD><TD>            MapEntry&lt;K,V&gt; entry = innerMap.get(e.getKey());</TD></TR><TR CLASS="z"><TD CLASS="l">1039</TD><TD>            if (entry!=null &amp;&amp; entry.isActive() &amp;&amp; value.equals(entry.getValue())) return true;</TD></TR><TR CLASS="z"><TD CLASS="l">1040</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1041</TD><TD>        return false;</TD></TR><TR><TD CLASS="l"><A NAME="7">1042</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">1043</TD><TD> </TD></TR><TR><TD CLASS="l">1044</TD><TD>    @Override</TD></TR><TR><TD CLASS="l">1045</TD><TD>    public Object clone() {</TD></TR><TR CLASS="z"><TD CLASS="l">1046</TD><TD>        throw new UnsupportedOperationException(&#34;This operation is not valid on a replicated map&#34;);</TD></TR><TR><TD CLASS="l">1047</TD><TD>    }</TD></TR><TR><TD CLASS="l">1048</TD><TD> </TD></TR><TR><TD CLASS="l">1049</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1050</TD><TD>     * Returns the entire contents of the map</TD></TR><TR><TD CLASS="l">1051</TD><TD>     * Map.Entry.getValue() will return a LazyReplicatedMap.MapEntry object containing all the information</TD></TR><TR><TD CLASS="l"><A NAME="b">1052</A></TD><TD>     * about the object.</TD></TR><TR><TD CLASS="l">1053</TD><TD>     * @return Set</TD></TR><TR><TD CLASS="l">1054</TD><TD>     */</TD></TR><TR><TD CLASS="l">1055</TD><TD>    public Set&lt;Map.Entry&lt;K,MapEntry&lt;K,V&gt;&gt;&gt; entrySetFull() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="26">1056</A></TD><TD>        return innerMap.entrySet();</TD></TR><TR><TD CLASS="l">1057</TD><TD>    }</TD></TR><TR><TD CLASS="l">1058</TD><TD> </TD></TR><TR><TD CLASS="l">1059</TD><TD>    public Set&lt;K&gt; keySetFull() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="3c">1060</A></TD><TD>        return innerMap.keySet();</TD></TR><TR><TD CLASS="l">1061</TD><TD>    }</TD></TR><TR><TD CLASS="l">1062</TD><TD> </TD></TR><TR><TD CLASS="l">1063</TD><TD>    public int sizeFull() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="a">1064</A></TD><TD>        return innerMap.size();</TD></TR><TR><TD CLASS="l">1065</TD><TD>    }</TD></TR><TR><TD CLASS="l">1066</TD><TD> </TD></TR><TR><TD CLASS="l">1067</TD><TD>    public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {</TD></TR><TR CLASS="z"><TD CLASS="l">1068</TD><TD>        LinkedHashSet&lt;Map.Entry&lt;K,V&gt;&gt; set = new LinkedHashSet&lt;Map.Entry&lt;K,V&gt;&gt;(innerMap.size());</TD></TR><TR CLASS="z"><TD CLASS="l">1069</TD><TD>        Iterator&lt;Map.Entry&lt;K,MapEntry&lt;K,V&gt;&gt;&gt; i = innerMap.entrySet().iterator();</TD></TR><TR CLASS="z"><TD CLASS="l">1070</TD><TD>        while ( i.hasNext() ) {</TD></TR><TR CLASS="z"><TD CLASS="l">1071</TD><TD>            Map.Entry&lt;?,?&gt; e = i.next();</TD></TR><TR CLASS="z"><TD CLASS="l">1072</TD><TD>            Object key = e.getKey();</TD></TR><TR CLASS="z"><TD CLASS="l">1073</TD><TD>            MapEntry&lt;K,V&gt; entry = innerMap.get(key);</TD></TR><TR CLASS="z"><TD CLASS="l">1074</TD><TD>            if ( entry != null &amp;&amp; entry.isActive() ) {</TD></TR><TR CLASS="z"><TD CLASS="l">1075</TD><TD>                set.add(entry);</TD></TR><TR><TD CLASS="l">1076</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">1077</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1078</TD><TD>        return Collections.unmodifiableSet(set);</TD></TR><TR><TD CLASS="l">1079</TD><TD>    }</TD></TR><TR><TD CLASS="l"><A NAME="25">1080</A></TD><TD> </TD></TR><TR><TD CLASS="l">1081</TD><TD>    public Set&lt;K&gt; keySet() {</TD></TR><TR><TD CLASS="l">1082</TD><TD>        //todo implement</TD></TR><TR><TD CLASS="l">1083</TD><TD>        //should only return keys where this is active.</TD></TR><TR CLASS="z"><TD CLASS="l">1084</TD><TD>        LinkedHashSet&lt;K&gt; set = new LinkedHashSet&lt;K&gt;(innerMap.size());</TD></TR><TR CLASS="z"><TD CLASS="l">1085</TD><TD>        Iterator&lt;Map.Entry&lt;K,MapEntry&lt;K,V&gt;&gt;&gt; i = innerMap.entrySet().iterator();</TD></TR><TR CLASS="z"><TD CLASS="l">1086</TD><TD>        while ( i.hasNext() ) {</TD></TR><TR CLASS="z"><TD CLASS="l">1087</TD><TD>            Map.Entry&lt;K,MapEntry&lt;K,V&gt;&gt; e = i.next();</TD></TR><TR CLASS="z"><TD CLASS="l">1088</TD><TD>            K key = e.getKey();</TD></TR><TR CLASS="z"><TD CLASS="l">1089</TD><TD>            MapEntry&lt;K,V&gt; entry = innerMap.get(key);</TD></TR><TR CLASS="z"><TD CLASS="l">1090</TD><TD>            if ( entry!=null &amp;&amp; entry.isActive() ) set.add(key);</TD></TR><TR CLASS="z"><TD CLASS="l">1091</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1092</TD><TD>        return Collections.unmodifiableSet(set);</TD></TR><TR><TD CLASS="l">1093</TD><TD> </TD></TR><TR><TD CLASS="l">1094</TD><TD>    }</TD></TR><TR><TD CLASS="l">1095</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="3b">1096</A></TD><TD> </TD></TR><TR><TD CLASS="l">1097</TD><TD>    public int size() {</TD></TR><TR><TD CLASS="l">1098</TD><TD>        //todo, implement a counter variable instead</TD></TR><TR><TD CLASS="l">1099</TD><TD>        //only count active members in this node</TD></TR><TR CLASS="z"><TD CLASS="l">1100</TD><TD>        int counter = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">1101</TD><TD>        Iterator&lt;Map.Entry&lt;K,MapEntry&lt;K,V&gt;&gt;&gt; it = innerMap.entrySet().iterator();</TD></TR><TR CLASS="z"><TD CLASS="l">1102</TD><TD>        while (it!=null &amp;&amp; it.hasNext() ) {</TD></TR><TR CLASS="z"><TD CLASS="l">1103</TD><TD>            Map.Entry&lt;?,?&gt; e = it.next();</TD></TR><TR CLASS="z"><TD CLASS="l">1104</TD><TD>            if ( e != null ) {</TD></TR><TR CLASS="z"><TD CLASS="l">1105</TD><TD>                MapEntry&lt;K,V&gt; entry = innerMap.get(e.getKey());</TD></TR><TR CLASS="z"><TD CLASS="l">1106</TD><TD>                if (entry!=null &amp;&amp; entry.isActive() &amp;&amp; entry.getValue() != null) counter++;</TD></TR><TR><TD CLASS="l">1107</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">1108</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="23">1109</A></TD><TD>        return counter;</TD></TR><TR><TD CLASS="l">1110</TD><TD>    }</TD></TR><TR><TD CLASS="l">1111</TD><TD> </TD></TR><TR><TD CLASS="l">1112</TD><TD>    public boolean isEmpty() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="3e">1113</A></TD><TD>        return size()==0;</TD></TR><TR><TD CLASS="l">1114</TD><TD>    }</TD></TR><TR><TD CLASS="l">1115</TD><TD> </TD></TR><TR><TD CLASS="l">1116</TD><TD>    public Collection&lt;V&gt; values() {</TD></TR><TR CLASS="z"><TD CLASS="l">1117</TD><TD>        ArrayList&lt;V&gt; values = new ArrayList&lt;V&gt;();</TD></TR><TR CLASS="z"><TD CLASS="l">1118</TD><TD>        Iterator&lt;Map.Entry&lt;K,MapEntry&lt;K,V&gt;&gt;&gt; i = innerMap.entrySet().iterator();</TD></TR><TR CLASS="z"><TD CLASS="l">1119</TD><TD>        while ( i.hasNext() ) {</TD></TR><TR CLASS="z"><TD CLASS="l">1120</TD><TD>            Map.Entry&lt;K,MapEntry&lt;K,V&gt;&gt; e = i.next();</TD></TR><TR CLASS="z"><TD CLASS="l">1121</TD><TD>            MapEntry&lt;K,V&gt; entry = innerMap.get(e.getKey());</TD></TR><TR CLASS="z"><TD CLASS="l">1122</TD><TD>            if (entry!=null &amp;&amp; entry.isActive() &amp;&amp; entry.getValue()!=null) values.add(entry.getValue());</TD></TR><TR CLASS="z"><TD CLASS="l">1123</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1124</TD><TD>        return Collections.unmodifiableCollection(values);</TD></TR><TR><TD CLASS="l">1125</TD><TD>    }</TD></TR><TR><TD CLASS="l">1126</TD><TD> </TD></TR><TR><TD CLASS="l">1127</TD><TD> </TD></TR><TR><TD CLASS="l">1128</TD><TD>//------------------------------------------------------------------------------</TD></TR><TR><TD CLASS="l">1129</TD><TD>//                Map Entry class</TD></TR><TR><TD CLASS="l">1130</TD><TD>//------------------------------------------------------------------------------</TD></TR><TR><TD CLASS="l">1131</TD><TD>    public static class MapEntry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {</TD></TR><TR><TD CLASS="l">1132</TD><TD>        private boolean backup;</TD></TR><TR><TD CLASS="l">1133</TD><TD>        private boolean proxy;</TD></TR><TR><TD CLASS="l">1134</TD><TD>        private Member[] backupNodes;</TD></TR><TR><TD CLASS="l"><A NAME="40">1135</A></TD><TD>        private Member primary;</TD></TR><TR><TD CLASS="l">1136</TD><TD>        private K key;</TD></TR><TR><TD CLASS="l">1137</TD><TD>        private V value;</TD></TR><TR><TD CLASS="l">1138</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1139</TD><TD>        public MapEntry(K key, V value) {</TD></TR><TR CLASS="z"><TD CLASS="l">1140</TD><TD>            setKey(key);</TD></TR><TR CLASS="z"><TD CLASS="l">1141</TD><TD>            setValue(value);</TD></TR><TR><TD CLASS="l"><A NAME="4c">1142</A></TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1143</TD><TD>        }</TD></TR><TR><TD CLASS="l">1144</TD><TD> </TD></TR><TR><TD CLASS="l">1145</TD><TD>        public boolean isKeySerializable() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="50">1146</A></TD><TD>            return (key == null) || (key instanceof Serializable);</TD></TR><TR><TD CLASS="l">1147</TD><TD>        }</TD></TR><TR><TD CLASS="l">1148</TD><TD> </TD></TR><TR><TD CLASS="l">1149</TD><TD>        public boolean isValueSerializable() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="4f">1150</A></TD><TD>            return (value==null) || (value instanceof Serializable);</TD></TR><TR><TD CLASS="l">1151</TD><TD>        }</TD></TR><TR><TD CLASS="l">1152</TD><TD> </TD></TR><TR><TD CLASS="l">1153</TD><TD>        public boolean isSerializable() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="4a">1154</A></TD><TD>            return isKeySerializable() &amp;&amp; isValueSerializable();</TD></TR><TR><TD CLASS="l">1155</TD><TD>        }</TD></TR><TR><TD CLASS="l">1156</TD><TD> </TD></TR><TR><TD CLASS="l">1157</TD><TD>        public boolean isBackup() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="51">1158</A></TD><TD>            return backup;</TD></TR><TR><TD CLASS="l">1159</TD><TD>        }</TD></TR><TR><TD CLASS="l">1160</TD><TD> </TD></TR><TR><TD CLASS="l">1161</TD><TD>        public void setBackup(boolean backup) {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="4e">1162</A></TD><TD>            this.backup = backup;</TD></TR><TR CLASS="z"><TD CLASS="l">1163</TD><TD>        }</TD></TR><TR><TD CLASS="l">1164</TD><TD> </TD></TR><TR><TD CLASS="l">1165</TD><TD>        public boolean isProxy() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="4d">1166</A></TD><TD>            return proxy;</TD></TR><TR><TD CLASS="l">1167</TD><TD>        }</TD></TR><TR><TD CLASS="l">1168</TD><TD> </TD></TR><TR><TD CLASS="l">1169</TD><TD>        public boolean isPrimary() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="49">1170</A></TD><TD>            return (!proxy &amp;&amp; !backup);</TD></TR><TR><TD CLASS="l">1171</TD><TD>        }</TD></TR><TR><TD CLASS="l">1172</TD><TD> </TD></TR><TR><TD CLASS="l">1173</TD><TD>        public boolean isActive() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="55">1174</A></TD><TD>            return !proxy;</TD></TR><TR><TD CLASS="l">1175</TD><TD>        }</TD></TR><TR><TD CLASS="l">1176</TD><TD> </TD></TR><TR><TD CLASS="l">1177</TD><TD>        public void setProxy(boolean proxy) {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="4b">1178</A></TD><TD>            this.proxy = proxy;</TD></TR><TR CLASS="z"><TD CLASS="l">1179</TD><TD>        }</TD></TR><TR><TD CLASS="l">1180</TD><TD> </TD></TR><TR><TD CLASS="l">1181</TD><TD>        public boolean isDiffable() {</TD></TR><TR CLASS="z"><TD CLASS="l">1182</TD><TD>            return (value instanceof ReplicatedMapEntry) &amp;&amp;</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="52">1183</A></TD><TD>                   ((ReplicatedMapEntry)value).isDiffable();</TD></TR><TR><TD CLASS="l">1184</TD><TD>        }</TD></TR><TR><TD CLASS="l">1185</TD><TD> </TD></TR><TR><TD CLASS="l">1186</TD><TD>        public void setBackupNodes(Member[] nodes) {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="44">1187</A></TD><TD>            this.backupNodes = nodes;</TD></TR><TR CLASS="z"><TD CLASS="l">1188</TD><TD>        }</TD></TR><TR><TD CLASS="l">1189</TD><TD> </TD></TR><TR><TD CLASS="l">1190</TD><TD>        public Member[] getBackupNodes() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="54">1191</A></TD><TD>            return backupNodes;</TD></TR><TR><TD CLASS="l">1192</TD><TD>        }</TD></TR><TR><TD CLASS="l">1193</TD><TD> </TD></TR><TR><TD CLASS="l">1194</TD><TD>        public void setPrimary(Member m) {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="46">1195</A></TD><TD>            primary = m;</TD></TR><TR CLASS="z"><TD CLASS="l">1196</TD><TD>        }</TD></TR><TR><TD CLASS="l">1197</TD><TD> </TD></TR><TR><TD CLASS="l">1198</TD><TD>        public Member getPrimary() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="47">1199</A></TD><TD>            return primary;</TD></TR><TR><TD CLASS="l">1200</TD><TD>        }</TD></TR><TR><TD CLASS="l">1201</TD><TD> </TD></TR><TR><TD CLASS="l">1202</TD><TD>        public V getValue() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="56">1203</A></TD><TD>            return value;</TD></TR><TR><TD CLASS="l">1204</TD><TD>        }</TD></TR><TR><TD CLASS="l">1205</TD><TD> </TD></TR><TR><TD CLASS="l">1206</TD><TD>        public V setValue(V value) {</TD></TR><TR CLASS="z"><TD CLASS="l">1207</TD><TD>            V old = this.value;</TD></TR><TR CLASS="z"><TD CLASS="l">1208</TD><TD>            this.value = value;</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="45">1209</A></TD><TD>            return old;</TD></TR><TR><TD CLASS="l">1210</TD><TD>        }</TD></TR><TR><TD CLASS="l">1211</TD><TD> </TD></TR><TR><TD CLASS="l">1212</TD><TD>        public K getKey() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="53">1213</A></TD><TD>            return key;</TD></TR><TR><TD CLASS="l">1214</TD><TD>        }</TD></TR><TR><TD CLASS="l">1215</TD><TD> </TD></TR><TR><TD CLASS="l">1216</TD><TD>        public K setKey(K key) {</TD></TR><TR CLASS="z"><TD CLASS="l">1217</TD><TD>            K old = this.key;</TD></TR><TR CLASS="z"><TD CLASS="l">1218</TD><TD>            this.key = key;</TD></TR><TR CLASS="z"><TD CLASS="l">1219</TD><TD>            return old;</TD></TR><TR><TD CLASS="l"><A NAME="48">1220</A></TD><TD>        }</TD></TR><TR><TD CLASS="l">1221</TD><TD> </TD></TR><TR><TD CLASS="l">1222</TD><TD>        @Override</TD></TR><TR><TD CLASS="l">1223</TD><TD>        public int hashCode() {</TD></TR><TR CLASS="z"><TD CLASS="l">1224</TD><TD>            return key.hashCode();</TD></TR><TR><TD CLASS="l"><A NAME="43">1225</A></TD><TD>        }</TD></TR><TR><TD CLASS="l">1226</TD><TD> </TD></TR><TR><TD CLASS="l">1227</TD><TD>        @Override</TD></TR><TR><TD CLASS="l">1228</TD><TD>        public boolean equals(Object o) {</TD></TR><TR CLASS="z"><TD CLASS="l">1229</TD><TD>            return key.equals(o);</TD></TR><TR><TD CLASS="l">1230</TD><TD>        }</TD></TR><TR><TD CLASS="l">1231</TD><TD> </TD></TR><TR><TD CLASS="l">1232</TD><TD>        /**</TD></TR><TR><TD CLASS="l">1233</TD><TD>         * apply a diff, or an entire object</TD></TR><TR><TD CLASS="l">1234</TD><TD>         * @param data byte[]</TD></TR><TR><TD CLASS="l">1235</TD><TD>         * @param offset int</TD></TR><TR><TD CLASS="l">1236</TD><TD>         * @param length int</TD></TR><TR><TD CLASS="l">1237</TD><TD>         * @param diff boolean</TD></TR><TR><TD CLASS="l">1238</TD><TD>         * @throws IOException</TD></TR><TR><TD CLASS="l"><A NAME="42">1239</A></TD><TD>         * @throws ClassNotFoundException</TD></TR><TR><TD CLASS="l">1240</TD><TD>         */</TD></TR><TR><TD CLASS="l">1241</TD><TD>        @SuppressWarnings(&#34;unchecked&#34;)</TD></TR><TR><TD CLASS="l">1242</TD><TD>        public void apply(byte[] data, int offset, int length, boolean diff) throws IOException, ClassNotFoundException {</TD></TR><TR CLASS="z"><TD CLASS="l">1243</TD><TD>            if (isDiffable() &amp;&amp; diff) {</TD></TR><TR CLASS="z"><TD CLASS="l">1244</TD><TD>                ReplicatedMapEntry rentry = (ReplicatedMapEntry) value;</TD></TR><TR CLASS="z"><TD CLASS="l">1245</TD><TD>                rentry.lock();</TD></TR><TR><TD CLASS="l">1246</TD><TD>                try {</TD></TR><TR CLASS="z"><TD CLASS="l">1247</TD><TD>                    rentry.applyDiff(data, offset, length);</TD></TR><TR CLASS="z"><TD CLASS="l">1248</TD><TD>                } finally {</TD></TR><TR CLASS="z"><TD CLASS="l">1249</TD><TD>                    rentry.unlock();</TD></TR><TR CLASS="z"><TD CLASS="l">1250</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">1251</TD><TD>            } else if (length == 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">1252</TD><TD>                value = null;</TD></TR><TR CLASS="z"><TD CLASS="l">1253</TD><TD>                proxy = true;</TD></TR><TR><TD CLASS="l">1254</TD><TD>            } else {</TD></TR><TR CLASS="z"><TD CLASS="l">1255</TD><TD>                value = (V) XByteBuffer.deserialize(data, offset, length);</TD></TR><TR><TD CLASS="l">1256</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="57">1257</A></TD><TD>        }</TD></TR><TR><TD CLASS="l">1258</TD><TD> </TD></TR><TR><TD CLASS="l">1259</TD><TD>        @Override</TD></TR><TR><TD CLASS="l">1260</TD><TD>        public String toString() {</TD></TR><TR CLASS="z"><TD CLASS="l">1261</TD><TD>            StringBuilder buf = new StringBuilder(&#34;MapEntry[key:&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">1262</TD><TD>            buf.append(getKey()).append(&#34;; &#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">1263</TD><TD>            buf.append(&#34;value:&#34;).append(getValue()).append(&#34;; &#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">1264</TD><TD>            buf.append(&#34;primary:&#34;).append(isPrimary()).append(&#34;; &#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">1265</TD><TD>            buf.append(&#34;backup:&#34;).append(isBackup()).append(&#34;; &#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">1266</TD><TD>            buf.append(&#34;proxy:&#34;).append(isProxy()).append(&#34;;]&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">1267</TD><TD>            return buf.toString();</TD></TR><TR><TD CLASS="l">1268</TD><TD>        }</TD></TR><TR><TD CLASS="l">1269</TD><TD> </TD></TR><TR><TD CLASS="l">1270</TD><TD>    }</TD></TR><TR><TD CLASS="l">1271</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="58">1272</A></TD><TD>//------------------------------------------------------------------------------</TD></TR><TR><TD CLASS="l">1273</TD><TD>//                map message to send to and from other maps</TD></TR><TR><TD CLASS="l">1274</TD><TD>//------------------------------------------------------------------------------</TD></TR><TR><TD CLASS="l">1275</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1276</TD><TD>    public static class MapMessage implements Serializable {</TD></TR><TR><TD CLASS="l">1277</TD><TD>        private static final long serialVersionUID = 1L;</TD></TR><TR><TD CLASS="l">1278</TD><TD>        public static final int MSG_BACKUP = 1;</TD></TR><TR><TD CLASS="l">1279</TD><TD>        public static final int MSG_RETRIEVE_BACKUP = 2;</TD></TR><TR><TD CLASS="l">1280</TD><TD>        public static final int MSG_PROXY = 3;</TD></TR><TR><TD CLASS="l">1281</TD><TD>        public static final int MSG_REMOVE = 4;</TD></TR><TR><TD CLASS="l">1282</TD><TD>        public static final int MSG_STATE = 5;</TD></TR><TR><TD CLASS="l">1283</TD><TD>        public static final int MSG_START = 6;</TD></TR><TR><TD CLASS="l">1284</TD><TD>        public static final int MSG_STOP = 7;</TD></TR><TR><TD CLASS="l">1285</TD><TD>        public static final int MSG_INIT = 8;</TD></TR><TR><TD CLASS="l">1286</TD><TD>        public static final int MSG_COPY = 9;</TD></TR><TR><TD CLASS="l">1287</TD><TD>        public static final int MSG_STATE_COPY = 10;</TD></TR><TR><TD CLASS="l">1288</TD><TD>        public static final int MSG_ACCESS = 11;</TD></TR><TR><TD CLASS="l">1289</TD><TD> </TD></TR><TR><TD CLASS="l">1290</TD><TD>        private byte[] mapId;</TD></TR><TR><TD CLASS="l">1291</TD><TD>        private int msgtype;</TD></TR><TR><TD CLASS="l">1292</TD><TD>        private boolean diff;</TD></TR><TR><TD CLASS="l">1293</TD><TD>        private transient Serializable key;</TD></TR><TR><TD CLASS="l">1294</TD><TD>        private transient Serializable value;</TD></TR><TR><TD CLASS="l">1295</TD><TD>        private byte[] valuedata;</TD></TR><TR><TD CLASS="l">1296</TD><TD>        private byte[] keydata;</TD></TR><TR><TD CLASS="l">1297</TD><TD>        private byte[] diffvalue;</TD></TR><TR><TD CLASS="l">1298</TD><TD>        private Member[] nodes;</TD></TR><TR><TD CLASS="l"><A NAME="6e">1299</A></TD><TD>        private Member primary;</TD></TR><TR><TD CLASS="l">1300</TD><TD> </TD></TR><TR><TD CLASS="l">1301</TD><TD>        @Override</TD></TR><TR><TD CLASS="l">1302</TD><TD>        public String toString() {</TD></TR><TR CLASS="z"><TD CLASS="l">1303</TD><TD>            StringBuilder buf = new StringBuilder(&#34;MapMessage[context=&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">1304</TD><TD>            buf.append(new String(mapId));</TD></TR><TR CLASS="z"><TD CLASS="l">1305</TD><TD>            buf.append(&#34;; type=&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">1306</TD><TD>            buf.append(getTypeDesc());</TD></TR><TR CLASS="z"><TD CLASS="l">1307</TD><TD>            buf.append(&#34;; key=&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">1308</TD><TD>            buf.append(key);</TD></TR><TR CLASS="z"><TD CLASS="l">1309</TD><TD>            buf.append(&#34;; value=&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">1310</TD><TD>            buf.append(value);</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="65">1311</A></TD><TD>            return buf.toString();</TD></TR><TR><TD CLASS="l">1312</TD><TD>        }</TD></TR><TR><TD CLASS="l">1313</TD><TD> </TD></TR><TR><TD CLASS="l">1314</TD><TD>        public String getTypeDesc() {</TD></TR><TR CLASS="z"><TD CLASS="l">1315</TD><TD>            switch (msgtype) {</TD></TR><TR CLASS="z"><TD CLASS="l">1316</TD><TD>                case MSG_BACKUP: return &#34;MSG_BACKUP&#34;;</TD></TR><TR CLASS="z"><TD CLASS="l">1317</TD><TD>                case MSG_RETRIEVE_BACKUP: return &#34;MSG_RETRIEVE_BACKUP&#34;;</TD></TR><TR CLASS="z"><TD CLASS="l">1318</TD><TD>                case MSG_PROXY: return &#34;MSG_PROXY&#34;;</TD></TR><TR CLASS="z"><TD CLASS="l">1319</TD><TD>                case MSG_REMOVE: return &#34;MSG_REMOVE&#34;;</TD></TR><TR CLASS="z"><TD CLASS="l">1320</TD><TD>                case MSG_STATE: return &#34;MSG_STATE&#34;;</TD></TR><TR CLASS="z"><TD CLASS="l">1321</TD><TD>                case MSG_START: return &#34;MSG_START&#34;;</TD></TR><TR CLASS="z"><TD CLASS="l">1322</TD><TD>                case MSG_STOP: return &#34;MSG_STOP&#34;;</TD></TR><TR CLASS="z"><TD CLASS="l">1323</TD><TD>                case MSG_INIT: return &#34;MSG_INIT&#34;;</TD></TR><TR CLASS="z"><TD CLASS="l">1324</TD><TD>                case MSG_STATE_COPY: return &#34;MSG_STATE_COPY&#34;;</TD></TR><TR CLASS="z"><TD CLASS="l">1325</TD><TD>                case MSG_COPY: return &#34;MSG_COPY&#34;;</TD></TR><TR CLASS="z"><TD CLASS="l">1326</TD><TD>                case MSG_ACCESS: return &#34;MSG_ACCESS&#34;;</TD></TR><TR CLASS="z"><TD CLASS="l">1327</TD><TD>                default : return &#34;UNKNOWN&#34;;</TD></TR><TR><TD CLASS="l">1328</TD><TD>            }</TD></TR><TR><TD CLASS="l">1329</TD><TD>        }</TD></TR><TR><TD CLASS="l">1330</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="59">1331</A></TD><TD>        /**</TD></TR><TR><TD CLASS="l">1332</TD><TD>         * @deprecated  Unused - will be removed in Tomcat 8.0.x</TD></TR><TR><TD CLASS="l">1333</TD><TD>         */</TD></TR><TR><TD CLASS="l">1334</TD><TD>        @Deprecated</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="5a">1335</A></TD><TD>        public MapMessage() {}</TD></TR><TR><TD CLASS="l">1336</TD><TD> </TD></TR><TR><TD CLASS="l">1337</TD><TD>        public MapMessage(byte[] mapId,int msgtype, boolean diff,</TD></TR><TR><TD CLASS="l">1338</TD><TD>                          Serializable key, Serializable value,</TD></TR><TR CLASS="z"><TD CLASS="l">1339</TD><TD>                          byte[] diffvalue, Member primary, Member[] nodes)  {</TD></TR><TR CLASS="z"><TD CLASS="l">1340</TD><TD>            this.mapId = mapId;</TD></TR><TR CLASS="z"><TD CLASS="l">1341</TD><TD>            this.msgtype = msgtype;</TD></TR><TR CLASS="z"><TD CLASS="l">1342</TD><TD>            this.diff = diff;</TD></TR><TR CLASS="z"><TD CLASS="l">1343</TD><TD>            this.key = key;</TD></TR><TR CLASS="z"><TD CLASS="l">1344</TD><TD>            this.value = value;</TD></TR><TR CLASS="z"><TD CLASS="l">1345</TD><TD>            this.diffvalue = diffvalue;</TD></TR><TR CLASS="z"><TD CLASS="l">1346</TD><TD>            this.nodes = nodes;</TD></TR><TR CLASS="z"><TD CLASS="l">1347</TD><TD>            this.primary = primary;</TD></TR><TR CLASS="z"><TD CLASS="l">1348</TD><TD>            setValue(value);</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="5d">1349</A></TD><TD>            setKey(key);</TD></TR><TR CLASS="z"><TD CLASS="l">1350</TD><TD>        }</TD></TR><TR><TD CLASS="l">1351</TD><TD> </TD></TR><TR><TD CLASS="l">1352</TD><TD>        public void deserialize(ClassLoader[] cls) throws IOException, ClassNotFoundException {</TD></TR><TR CLASS="z"><TD CLASS="l">1353</TD><TD>            key(cls);</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="63">1354</A></TD><TD>            value(cls);</TD></TR><TR CLASS="z"><TD CLASS="l">1355</TD><TD>        }</TD></TR><TR><TD CLASS="l">1356</TD><TD> </TD></TR><TR><TD CLASS="l">1357</TD><TD>        public int getMsgType() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="68">1358</A></TD><TD>            return msgtype;</TD></TR><TR><TD CLASS="l">1359</TD><TD>        }</TD></TR><TR><TD CLASS="l">1360</TD><TD> </TD></TR><TR><TD CLASS="l">1361</TD><TD>        public boolean isDiff() {</TD></TR><TR CLASS="z"><TD CLASS="l">1362</TD><TD>            return diff;</TD></TR><TR><TD CLASS="l"><A NAME="60">1363</A></TD><TD>        }</TD></TR><TR><TD CLASS="l">1364</TD><TD> </TD></TR><TR><TD CLASS="l">1365</TD><TD>        public Serializable getKey() {</TD></TR><TR><TD CLASS="l">1366</TD><TD>            try {</TD></TR><TR CLASS="z"><TD CLASS="l">1367</TD><TD>                return key(null);</TD></TR><TR CLASS="z"><TD CLASS="l">1368</TD><TD>            } catch ( Exception x ) {</TD></TR><TR CLASS="z"><TD CLASS="l">1369</TD><TD>                throw new RuntimeException(&#34;Deserialization error of the MapMessage.key&#34;, x);</TD></TR><TR><TD CLASS="l"><A NAME="69">1370</A></TD><TD>            }</TD></TR><TR><TD CLASS="l">1371</TD><TD>        }</TD></TR><TR><TD CLASS="l">1372</TD><TD> </TD></TR><TR><TD CLASS="l">1373</TD><TD>        public Serializable key(ClassLoader[] cls) throws IOException, ClassNotFoundException {</TD></TR><TR CLASS="z"><TD CLASS="l">1374</TD><TD>            if ( key!=null ) return key;</TD></TR><TR CLASS="z"><TD CLASS="l">1375</TD><TD>            if ( keydata == null || keydata.length == 0 ) return null;</TD></TR><TR CLASS="z"><TD CLASS="l">1376</TD><TD>            key = XByteBuffer.deserialize(keydata,0,keydata.length,cls);</TD></TR><TR CLASS="z"><TD CLASS="l">1377</TD><TD>            keydata = null;</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="61">1378</A></TD><TD>            return key;</TD></TR><TR><TD CLASS="l">1379</TD><TD>        }</TD></TR><TR><TD CLASS="l">1380</TD><TD> </TD></TR><TR><TD CLASS="l">1381</TD><TD>        public byte[] getKeyData() {</TD></TR><TR CLASS="z"><TD CLASS="l">1382</TD><TD>            return keydata;</TD></TR><TR><TD CLASS="l"><A NAME="66">1383</A></TD><TD>        }</TD></TR><TR><TD CLASS="l">1384</TD><TD> </TD></TR><TR><TD CLASS="l">1385</TD><TD>        public Serializable getValue() {</TD></TR><TR><TD CLASS="l">1386</TD><TD>            try {</TD></TR><TR CLASS="z"><TD CLASS="l">1387</TD><TD>                return value(null);</TD></TR><TR CLASS="z"><TD CLASS="l">1388</TD><TD>            } catch ( Exception x ) {</TD></TR><TR CLASS="z"><TD CLASS="l">1389</TD><TD>                throw new RuntimeException(&#34;Deserialization error of the MapMessage.value&#34;, x);</TD></TR><TR><TD CLASS="l"><A NAME="6f">1390</A></TD><TD>            }</TD></TR><TR><TD CLASS="l">1391</TD><TD>        }</TD></TR><TR><TD CLASS="l">1392</TD><TD> </TD></TR><TR><TD CLASS="l">1393</TD><TD>        public Serializable value(ClassLoader[] cls) throws IOException, ClassNotFoundException  {</TD></TR><TR CLASS="z"><TD CLASS="l">1394</TD><TD>            if ( value!=null ) return value;</TD></TR><TR CLASS="z"><TD CLASS="l">1395</TD><TD>            if ( valuedata == null || valuedata.length == 0 ) return null;</TD></TR><TR CLASS="z"><TD CLASS="l">1396</TD><TD>            value = XByteBuffer.deserialize(valuedata,0,valuedata.length,cls);</TD></TR><TR CLASS="z"><TD CLASS="l">1397</TD><TD>            valuedata = null;</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="67">1398</A></TD><TD>            return value;</TD></TR><TR><TD CLASS="l">1399</TD><TD>        }</TD></TR><TR><TD CLASS="l">1400</TD><TD> </TD></TR><TR><TD CLASS="l">1401</TD><TD>        public byte[] getValueData() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="5f">1402</A></TD><TD>            return valuedata;</TD></TR><TR><TD CLASS="l">1403</TD><TD>        }</TD></TR><TR><TD CLASS="l">1404</TD><TD> </TD></TR><TR><TD CLASS="l">1405</TD><TD>        public byte[] getDiffValue() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="5e">1406</A></TD><TD>            return diffvalue;</TD></TR><TR><TD CLASS="l">1407</TD><TD>        }</TD></TR><TR><TD CLASS="l">1408</TD><TD> </TD></TR><TR><TD CLASS="l">1409</TD><TD>        public Member[] getBackupNodes() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="64">1410</A></TD><TD>            return nodes;</TD></TR><TR><TD CLASS="l">1411</TD><TD>        }</TD></TR><TR><TD CLASS="l">1412</TD><TD> </TD></TR><TR><TD CLASS="l">1413</TD><TD>        public Member getPrimary() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="6c">1414</A></TD><TD>            return primary;</TD></TR><TR><TD CLASS="l">1415</TD><TD>        }</TD></TR><TR><TD CLASS="l">1416</TD><TD> </TD></TR><TR><TD CLASS="l">1417</TD><TD>        private void setPrimary(Member m) {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="62">1418</A></TD><TD>            primary = m;</TD></TR><TR CLASS="z"><TD CLASS="l">1419</TD><TD>        }</TD></TR><TR><TD CLASS="l">1420</TD><TD> </TD></TR><TR><TD CLASS="l">1421</TD><TD>        public byte[] getMapId() {</TD></TR><TR CLASS="z"><TD CLASS="l">1422</TD><TD>            return mapId;</TD></TR><TR><TD CLASS="l"><A NAME="6d">1423</A></TD><TD>        }</TD></TR><TR><TD CLASS="l">1424</TD><TD> </TD></TR><TR><TD CLASS="l">1425</TD><TD>        public void setValue(Serializable value) {</TD></TR><TR><TD CLASS="l">1426</TD><TD>            try {</TD></TR><TR CLASS="z"><TD CLASS="l">1427</TD><TD>                if ( value != null ) valuedata = XByteBuffer.serialize(value);</TD></TR><TR CLASS="z"><TD CLASS="l">1428</TD><TD>                this.value = value;</TD></TR><TR CLASS="z"><TD CLASS="l">1429</TD><TD>            }catch ( IOException x ) {</TD></TR><TR CLASS="z"><TD CLASS="l">1430</TD><TD>                throw new RuntimeException(x);</TD></TR><TR CLASS="z"><TD CLASS="l">1431</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="6b">1432</A></TD><TD>        }</TD></TR><TR><TD CLASS="l">1433</TD><TD> </TD></TR><TR><TD CLASS="l">1434</TD><TD>        public void setKey(Serializable key) {</TD></TR><TR><TD CLASS="l">1435</TD><TD>            try {</TD></TR><TR CLASS="z"><TD CLASS="l">1436</TD><TD>                if (key != null) keydata = XByteBuffer.serialize(key);</TD></TR><TR CLASS="z"><TD CLASS="l">1437</TD><TD>                this.key = key;</TD></TR><TR CLASS="z"><TD CLASS="l">1438</TD><TD>            } catch (IOException x) {</TD></TR><TR CLASS="z"><TD CLASS="l">1439</TD><TD>                throw new RuntimeException(x);</TD></TR><TR CLASS="z"><TD CLASS="l">1440</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">1441</TD><TD>        }</TD></TR><TR><TD CLASS="l">1442</TD><TD> </TD></TR><TR><TD CLASS="l">1443</TD><TD>        /**</TD></TR><TR><TD CLASS="l"><A NAME="6a">1444</A></TD><TD>         * @deprecated  Unused - will be removed in 8.0.x</TD></TR><TR><TD CLASS="l">1445</TD><TD>         */</TD></TR><TR><TD CLASS="l">1446</TD><TD>        @Deprecated</TD></TR><TR><TD CLASS="l">1447</TD><TD>        protected Member[] readMembers(ObjectInput in) throws IOException {</TD></TR><TR CLASS="z"><TD CLASS="l">1448</TD><TD>            int nodecount = in.readInt();</TD></TR><TR CLASS="z"><TD CLASS="l">1449</TD><TD>            Member[] members = new Member[nodecount];</TD></TR><TR CLASS="z"><TD CLASS="l">1450</TD><TD>            for ( int i=0; i&lt;members.length; i++ ) {</TD></TR><TR CLASS="z"><TD CLASS="l">1451</TD><TD>                byte[] d = new byte[in.readInt()];</TD></TR><TR CLASS="z"><TD CLASS="l">1452</TD><TD>                in.readFully(d);</TD></TR><TR CLASS="z"><TD CLASS="l">1453</TD><TD>                if (d.length &gt; 0) members[i] = MemberImpl.getMember(d);</TD></TR><TR><TD CLASS="l">1454</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">1455</TD><TD>            return members;</TD></TR><TR><TD CLASS="l">1456</TD><TD>        }</TD></TR><TR><TD CLASS="l">1457</TD><TD> </TD></TR><TR><TD CLASS="l">1458</TD><TD>        /**</TD></TR><TR><TD CLASS="l"><A NAME="70">1459</A></TD><TD>         * @deprecated  Unused - will be removed in 8.0.x</TD></TR><TR><TD CLASS="l">1460</TD><TD>         */</TD></TR><TR><TD CLASS="l">1461</TD><TD>        @Deprecated</TD></TR><TR><TD CLASS="l">1462</TD><TD>        protected void writeMembers(ObjectOutput out,Member[] members) throws IOException {</TD></TR><TR CLASS="z"><TD CLASS="l">1463</TD><TD>            if ( members == null ) members = new Member[0];</TD></TR><TR CLASS="z"><TD CLASS="l">1464</TD><TD>            out.writeInt(members.length);</TD></TR><TR CLASS="z"><TD CLASS="l">1465</TD><TD>            for (int i=0; i&lt;members.length; i++ ) {</TD></TR><TR CLASS="z"><TD CLASS="l">1466</TD><TD>                if ( members[i] != null ) {</TD></TR><TR CLASS="z"><TD CLASS="l">1467</TD><TD>                    byte[] d = members[i] != null ? ( (MemberImpl)members[i]).getData(false) : new byte[0];</TD></TR><TR CLASS="z"><TD CLASS="l">1468</TD><TD>                    out.writeInt(d.length);</TD></TR><TR CLASS="z"><TD CLASS="l">1469</TD><TD>                    out.write(d);</TD></TR><TR><TD CLASS="l">1470</TD><TD>                }</TD></TR><TR><TD CLASS="l">1471</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">1472</TD><TD>        }</TD></TR><TR><TD CLASS="l">1473</TD><TD> </TD></TR><TR><TD CLASS="l">1474</TD><TD> </TD></TR><TR><TD CLASS="l">1475</TD><TD>        /**</TD></TR><TR><TD CLASS="l">1476</TD><TD>         * shallow clone</TD></TR><TR><TD CLASS="l"><A NAME="5c">1477</A></TD><TD>         * @return Object</TD></TR><TR><TD CLASS="l">1478</TD><TD>         */</TD></TR><TR><TD CLASS="l">1479</TD><TD>        @Override</TD></TR><TR><TD CLASS="l">1480</TD><TD>        public Object clone() {</TD></TR><TR CLASS="z"><TD CLASS="l">1481</TD><TD>            MapMessage msg = new MapMessage(this.mapId, this.msgtype, this.diff, this.key, this.value, this.diffvalue, this.primary, this.nodes);</TD></TR><TR CLASS="z"><TD CLASS="l">1482</TD><TD>            msg.keydata = this.keydata;</TD></TR><TR CLASS="z"><TD CLASS="l">1483</TD><TD>            msg.valuedata = this.valuedata;</TD></TR><TR CLASS="z"><TD CLASS="l">1484</TD><TD>            return msg;</TD></TR><TR><TD CLASS="l">1485</TD><TD>        }</TD></TR><TR><TD CLASS="l"><A NAME="11">1486</A></TD><TD>    } //MapMessage</TD></TR><TR><TD CLASS="l">1487</TD><TD> </TD></TR><TR><TD CLASS="l">1488</TD><TD> </TD></TR><TR><TD CLASS="l">1489</TD><TD>    public Channel getChannel() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="15">1490</A></TD><TD>        return channel;</TD></TR><TR><TD CLASS="l">1491</TD><TD>    }</TD></TR><TR><TD CLASS="l">1492</TD><TD> </TD></TR><TR><TD CLASS="l">1493</TD><TD>    public byte[] getMapContextName() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="1c">1494</A></TD><TD>        return mapContextName;</TD></TR><TR><TD CLASS="l">1495</TD><TD>    }</TD></TR><TR><TD CLASS="l">1496</TD><TD> </TD></TR><TR><TD CLASS="l">1497</TD><TD>    public RpcChannel getRpcChannel() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="1d">1498</A></TD><TD>        return rpcChannel;</TD></TR><TR><TD CLASS="l">1499</TD><TD>    }</TD></TR><TR><TD CLASS="l">1500</TD><TD> </TD></TR><TR><TD CLASS="l">1501</TD><TD>    public long getRpcTimeout() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="1e">1502</A></TD><TD>        return rpcTimeout;</TD></TR><TR><TD CLASS="l">1503</TD><TD>    }</TD></TR><TR><TD CLASS="l">1504</TD><TD> </TD></TR><TR><TD CLASS="l">1505</TD><TD>    public Object getStateMutex() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="24">1506</A></TD><TD>        return stateMutex;</TD></TR><TR><TD CLASS="l">1507</TD><TD>    }</TD></TR><TR><TD CLASS="l">1508</TD><TD> </TD></TR><TR><TD CLASS="l">1509</TD><TD>    public boolean isStateTransferred() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="19">1510</A></TD><TD>        return stateTransferred;</TD></TR><TR><TD CLASS="l">1511</TD><TD>    }</TD></TR><TR><TD CLASS="l">1512</TD><TD> </TD></TR><TR><TD CLASS="l">1513</TD><TD>    public MapOwner getMapOwner() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="13">1514</A></TD><TD>        return mapOwner;</TD></TR><TR><TD CLASS="l">1515</TD><TD>    }</TD></TR><TR><TD CLASS="l">1516</TD><TD> </TD></TR><TR><TD CLASS="l">1517</TD><TD>    public ClassLoader[] getExternalLoaders() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="12">1518</A></TD><TD>        return externalLoaders;</TD></TR><TR><TD CLASS="l">1519</TD><TD>    }</TD></TR><TR><TD CLASS="l">1520</TD><TD> </TD></TR><TR><TD CLASS="l">1521</TD><TD>    public int getChannelSendOptions() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="10">1522</A></TD><TD>        return channelSendOptions;</TD></TR><TR><TD CLASS="l">1523</TD><TD>    }</TD></TR><TR><TD CLASS="l">1524</TD><TD> </TD></TR><TR><TD CLASS="l">1525</TD><TD>    public long getAccessTimeout() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="3a">1526</A></TD><TD>        return accessTimeout;</TD></TR><TR><TD CLASS="l">1527</TD><TD>    }</TD></TR><TR><TD CLASS="l">1528</TD><TD> </TD></TR><TR><TD CLASS="l">1529</TD><TD>    public void setMapOwner(MapOwner mapOwner) {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="39">1530</A></TD><TD>        this.mapOwner = mapOwner;</TD></TR><TR CLASS="z"><TD CLASS="l">1531</TD><TD>    }</TD></TR><TR><TD CLASS="l">1532</TD><TD> </TD></TR><TR><TD CLASS="l">1533</TD><TD>    public void setExternalLoaders(ClassLoader[] externalLoaders) {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="38">1534</A></TD><TD>        this.externalLoaders = externalLoaders;</TD></TR><TR CLASS="z"><TD CLASS="l">1535</TD><TD>    }</TD></TR><TR><TD CLASS="l">1536</TD><TD> </TD></TR><TR><TD CLASS="l">1537</TD><TD>    public void setChannelSendOptions(int channelSendOptions) {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="37">1538</A></TD><TD>        this.channelSendOptions = channelSendOptions;</TD></TR><TR CLASS="z"><TD CLASS="l">1539</TD><TD>    }</TD></TR><TR><TD CLASS="l">1540</TD><TD> </TD></TR><TR><TD CLASS="l">1541</TD><TD>    public void setAccessTimeout(long accessTimeout) {</TD></TR><TR CLASS="z"><TD CLASS="l">1542</TD><TD>        this.accessTimeout = accessTimeout;</TD></TR><TR CLASS="z"><TD CLASS="l">1543</TD><TD>    }</TD></TR><TR><TD CLASS="l">1544</TD><TD> </TD></TR><TR><TD CLASS="l">1545</TD><TD>}</TD></TR></TABLE><P></P><TABLE WIDTH="100%" CLASS="hdft" CELLSPACING="0"><TR><TD CLASS="nv">[<A HREF="../index.html">all classes</A>][<A HREF="15.html">org.apache.catalina.tribes.tipis</A>]</TD></TR><TR><TD CLASS="tl"><A HREF="http://sourceforge.net/projects/emma">EMMA 2.1.5320 (stable)</A> (C) Vladimir Roubtsov</TD></TR></TABLE></BODY></HTML>